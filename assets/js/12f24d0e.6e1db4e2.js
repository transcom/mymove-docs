"use strict";(self.webpackChunkmymove_docs=self.webpackChunkmymove_docs||[]).push([[754],{74857:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));n(8209);const r={sidebar_position:5},o="Validation",l={unversionedId:"backend/guides/service-objects/validation",id:"backend/guides/service-objects/validation",title:"Validation",description:"We have to thoroughly validate user input to ensure it complies with our business rules for any mutations to data. To",source:"@site/docs/backend/guides/service-objects/validation.md",sourceDirName:"backend/guides/service-objects",slug:"/backend/guides/service-objects/validation",permalink:"/mymove-docs/docs/backend/guides/service-objects/validation",draft:!1,editUrl:"https://github.com/transcom/mymove-docs/edit/main/docs/backend/guides/service-objects/validation.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"backendSidebar",previous:{title:"Set Up Service Subpackage and Interface",permalink:"/mymove-docs/docs/backend/guides/service-objects/set-up-service-subpackage-and-interface"},next:{title:"Implementation",permalink:"/mymove-docs/docs/backend/guides/service-objects/implementation"}},s={},p=[{value:"The Pattern",id:"the-pattern",level:2},{value:"Implementing the Pattern",id:"implementing-the-pattern",level:2},{value:"<code>validation.go</code>",id:"validationgo",level:3},{value:"<code>validator</code> interface and the <code>Validate</code> function",id:"validator-interface-and-the-validate-function",level:4},{value:"Variations of <code>Validate</code> Signature",id:"variations-of-validate-signature",level:5},{value:"Implementing the <code>Validate</code> Interface",id:"implementing-the-validate-interface",level:5},{value:"Create the <code>validate&lt;Model&gt;</code> Function",id:"create-the-validatemodel-function",level:4},{value:"Testing <code>validation.go</code>",id:"testing-validationgo",level:4},{value:"Final <code>validation.go</code>",id:"final-validationgo",level:4},{value:"<code>rules.go</code>",id:"rulesgo",level:3},{value:"<code>checkID</code>",id:"checkid",level:4},{value:"<code>checkType</code>",id:"checktype",level:4},{value:"<code>checkName</code>",id:"checkname",level:4},{value:"Grouping <code>rules</code> Functions",id:"grouping-rules-functions",level:4},{value:"Final <code>rules.go</code>",id:"final-rulesgo",level:4},{value:"Recap",id:"recap",level:2},{value:"Examples",id:"examples",level:2},{value:"Resources",id:"resources",level:2}],c={toc:p},u="wrapper";function d(e){let{components:t,...n}=e;return(0,i.kt)(u,(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"validation"},"Validation"),(0,i.kt)("p",null,"We have to thoroughly validate user input to ensure it complies with our business rules for any mutations to data. To\nencourage development of minimal, modular functions to check each rule, we have developed a validation pattern that\nwe can use consistently throughout our service objects. We have also designed it to easily change which rules are\napplied based on the kind of user performing the action."),(0,i.kt)("h2",{id:"the-pattern"},"The Pattern"),(0,i.kt)("p",null,"As mentioned in the section on ",(0,i.kt)("a",{parentName:"p",href:"./structure#service-object-subpackage-structure"},"Service Object Subpackage Structure"),",\nour validation pattern revolves around using the files ",(0,i.kt)("inlineCode",{parentName:"p"},"rules.go")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"validation.go"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"validation.go")," contains the machinery that executes our validation in this service. It is almost entirely functional,\nand will generally look similar in most services. A lot of this code is boilerplate."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"rules.go")," contains our business logic. This is where we will write the functions that check each of our distinct\nbusiness rules for the object. They should be able to be called independently of each other. As business rules\nchange, this should likely be the main file that has to change, unless dependencies for validation change, but that\nwill be covered later."),(0,i.kt)("h2",{id:"implementing-the-pattern"},"Implementing the Pattern"),(0,i.kt)("p",null,"First things first, you'll need to identify some business rules or utilities that you'd like to implement.\nCommon checks will verify if the related move is available to the Prime contractor, if the ID/foreign key values on the\nbase object have been manipulated, if circumstantially required fields have been filled out, and so on."),(0,i.kt)("admonition",{title:"Advanced Golang",type:"caution"},(0,i.kt)("p",{parentName:"admonition"},"The validation pattern documented here makes use of some advanced Go patterns. If you're struggling with the syntax or\nwould like more context on what is happening, you can look at the ",(0,i.kt)("a",{parentName:"p",href:"#resources"},"resources section")," for helpful",(0,i.kt)("br",{parentName:"p"}),"\n","explanations and examples.")),(0,i.kt)("h3",{id:"validationgo"},(0,i.kt)("inlineCode",{parentName:"h3"},"validation.go")),(0,i.kt)("p",null,"We'll start with creating the ",(0,i.kt)("inlineCode",{parentName:"p"},"validation.go")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"validation_test.go")," files. In ",(0,i.kt)("inlineCode",{parentName:"p"},"validation.go"),", we'll set up our\nvalidator types and write the base function that handles running our checks on the data."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text",metastring:"{7,8}","{7,8}":!0},"mymove/\n\u251c\u2500\u2500 pkg/\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u251c\u2500\u2500 ...\n\u2502   \u2502   \u251c\u2500\u2500 pet/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 pet_service_test.go\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 validation.go       <- new file\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 validation_test.go  <- new file\n\u2502   \u2502   \u251c\u2500\u2500 ...\n")),(0,i.kt)("h4",{id:"validator-interface-and-the-validate-function"},(0,i.kt)("inlineCode",{parentName:"h4"},"validator")," interface and the ",(0,i.kt)("inlineCode",{parentName:"h4"},"Validate")," function"),(0,i.kt)("p",null,"Now we'll define an interface type that all of our validators will implement. This type will be private to our\nservice package and have one method, ",(0,i.kt)("inlineCode",{parentName:"p"},"Validate()"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/validation.go"',title:'"pkg/services/pet/validation.go"'},'package pet\n\nimport (\n    "github.com/transcom/mymove/pkg/appcontext"\n)\n\n// petValidator defines the interface for checking business rules for a pet\ntype petValidator interface {\n    Validate(appCtx appcontext.AppContext) error\n}\n')),(0,i.kt)("p",null,"Based on our general Go standards, we know this function (like many other functions) will take in the ",(0,i.kt)("inlineCode",{parentName:"p"},"AppContext"),'\nas its first argument. Since the action is "validate," it also makes sense that it would return an error. But what\nelse do we need?'),(0,i.kt)("p",null,"The parameters of ",(0,i.kt)("inlineCode",{parentName:"p"},"Validate()")," should include ",(0,i.kt)("strong",{parentName:"p"},"all model types")," that you will need to validate your business rules.\nThis will change on a case-by-case basis, but, at a minimum, you will generally include your subject model type."),(0,i.kt)("h5",{id:"variations-of-validate-signature"},"Variations of ",(0,i.kt)("inlineCode",{parentName:"h5"},"Validate")," Signature"),(0,i.kt)("p",null,"Since we're creating service objects for creating and updating pets, we know we'll need an argument that is of type\n",(0,i.kt)("inlineCode",{parentName:"p"},"models.Pet"),". Unfortunately, we don't have a set standard for how that argument should be used, nor how to handle\nthe updates. We'll talk about a couple of the ways you'll find in existing code, but then pick one to use for the\npurposes of these docs."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"original")," models. Looks something like this:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/validation.go"',title:'"pkg/services/pet/validation.go"'},'package pet\n\nimport (\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/models"\n)\n\n// petValidator defines the interface for checking business rules for a pet\ntype petValidator interface {\n    // Validate The newPet is assumed to be required, so that is a value type.\n    // The originalPet is optional, so it\'s a pointer type.\n    Validate(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error\n}\n')),(0,i.kt)("p",{parentName:"li"},"For this pattern, the following explains what ",(0,i.kt)("inlineCode",{parentName:"p"},"newPet")," (a.k.a. the ",(0,i.kt)("inlineCode",{parentName:"p"},"base"),") and ",(0,i.kt)("inlineCode",{parentName:"p"},"originalPet")," would contain for\n",(0,i.kt)("inlineCode",{parentName:"p"},"create")," vs ",(0,i.kt)("inlineCode",{parentName:"p"},"update"),":"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"create"),": ",(0,i.kt)("inlineCode",{parentName:"p"},"newPet")," would contain the information for the new ",(0,i.kt)("inlineCode",{parentName:"p"},"Pet"),", while ",(0,i.kt)("inlineCode",{parentName:"p"},"originalPet")," would be ",(0,i.kt)("inlineCode",{parentName:"p"},"nil"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"update"),": ",(0,i.kt)("inlineCode",{parentName:"p"},"newPet")," would contain the requested ",(0,i.kt)("em",{parentName:"p"},"final")," version of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pet"),", while ",(0,i.kt)("inlineCode",{parentName:"p"},"originalPet")," would\ncontain the original version of the pet. The ",(0,i.kt)("em",{parentName:"p"},"final")," version of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pet")," is the version that would be\nsaved to the database, meaning the original ",(0,i.kt)("inlineCode",{parentName:"p"},"Pet")," with the requested changes made to it already, in other words,\na merged version of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pet"),"."))),(0,i.kt)("p",{parentName:"li"},"Pros:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Validating the version of the model that would be saved to the database, so there's less of a chance for there\nto be invalid data saved.")),(0,i.kt)("p",{parentName:"li"},"Cons:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Can't easily see what changes are without comparing the ",(0,i.kt)("inlineCode",{parentName:"li"},"new")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"original")," versions."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"base")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"delta")," models. Looks something like this (there are variations that flip which comes first, and\nwhat they're called):"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/validation.go"',title:'"pkg/services/pet/validation.go"'},' package pet\n\n import (\n     "github.com/transcom/mymove/pkg/appcontext"\n     "github.com/transcom/mymove/pkg/models"\n )\n\n // petValidator defines the interface for checking business rules for a pet\n type petValidator interface {\n     // Validate The base Pet is assumed to be required, so that is a value type.\n     // The delta is optional, so it\'s a pointer type\n     Validate(appCtx appcontext.AppContext, pet models.Pet, delta *models.Pet) error\n }\n')),(0,i.kt)("p",{parentName:"li"},"For this pattern, the following explains what ",(0,i.kt)("inlineCode",{parentName:"p"},"pet")," (a.k.a. the ",(0,i.kt)("inlineCode",{parentName:"p"},"base"),") and ",(0,i.kt)("inlineCode",{parentName:"p"},"delta")," would contain for ",(0,i.kt)("inlineCode",{parentName:"p"},"create")," vs\n",(0,i.kt)("inlineCode",{parentName:"p"},"update"),":"),(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"create"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"pet")," would contain the information for the new ",(0,i.kt)("inlineCode",{parentName:"li"},"Pet"),", while ",(0,i.kt)("inlineCode",{parentName:"li"},"delta")," would be ",(0,i.kt)("inlineCode",{parentName:"li"},"nil"),"."),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"update"),": ",(0,i.kt)("inlineCode",{parentName:"li"},"pet")," would contain the original ",(0,i.kt)("inlineCode",{parentName:"li"},"Pet"),", while ",(0,i.kt)("inlineCode",{parentName:"li"},"delta")," would contain the ",(0,i.kt)("em",{parentName:"li"},"changes")," requested.")),(0,i.kt)("p",{parentName:"li"},"Pros:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Can easily see in the validation functions what the requested changes are, at least for fields that aren't\nbeing set to ",(0,i.kt)("inlineCode",{parentName:"li"},"nil"),", otherwise have to compare to the original to see if you're changing from a value to ",(0,i.kt)("inlineCode",{parentName:"li"},"nil"),".")),(0,i.kt)("p",{parentName:"li"},"Cons:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Not validating the version of the model that would be saved to the database, meaning there's potentially room\nfor errors to be introduced when the original model gets the requested changes applied.")))),(0,i.kt)("p",null,"For the purposes of these docs, we'll use the first pattern shown, using the merged and original versions of the ",(0,i.kt)("inlineCode",{parentName:"p"},"Pet"),"."),(0,i.kt)("h5",{id:"implementing-the-validate-interface"},"Implementing the ",(0,i.kt)("inlineCode",{parentName:"h5"},"Validate")," Interface"),(0,i.kt)("p",null,"Now that we've settled on a signature, we can also add the type that will implement this interface. We will make the\ntype a function type, which will enable us to write our rules using ",(0,i.kt)("a",{parentName:"p",href:"https://gobyexample.com/closures"},"closures"),". We\ncan define this new type in the ",(0,i.kt)("inlineCode",{parentName:"p"},"validation.go")," file, under the validator interface we defined in the previous section."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/validation.go"',title:'"pkg/services/pet/validation.go"'},'package pet\n\nimport (\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/models"\n)\n\n// petValidator defines the interface for checking business rules for a pet\ntype petValidator interface {\n    // Validate The newPet is assumed to be required, so that is a value type.\n    // The originalPet is optional, so it\'s a pointer type.\n    Validate(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error\n}\n\n// petValidatorFunc is an adapter that will convert a function into an implementation of petValidator\ntype petValidatorFunc func(appcontext.AppContext, models.Pet, *models.Pet) error\n\n// Validate fulfills the petValidator interface\nfunc (fn petValidatorFunc) Validate(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error {\n    return fn(appCtx, newPet, originalPet)\n}\n')),(0,i.kt)("p",null,"Note that all of these function signatures are the exact same. ",(0,i.kt)("strong",{parentName:"p"},"They must stay the same")," so that these types implement\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"petValidator")," interface defined above. Such is the nature of interfaces types. It might feel inconvenient to repeat\nthis signature over and over, but at least it forces us to be explicit about our input."),(0,i.kt)("h4",{id:"create-the-validatemodel-function"},"Create the ",(0,i.kt)("inlineCode",{parentName:"h4"},"validate<Model>")," Function"),(0,i.kt)("p",null,"Now we're going to define the function that will take in the necessary data and the validation functions that we\nshould run, run through all the validation functions, and return an error as appropriate. It will be called from the\nservice objects, meaning it will be the access point for all our validation."),(0,i.kt)("p",null,"We'll name this function based on what you are validating, so in our case, we'll name it ",(0,i.kt)("inlineCode",{parentName:"p"},"validatePet"),". Its\nsignature will look similar to the signatures we used earlier, with the addition of a new parameter called ",(0,i.kt)("inlineCode",{parentName:"p"},"checks"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/validation.go"',title:'"pkg/services/pet/validation.go"'},"package pet\n\n// Previous definitions omitted to focus on the new part for now\n\n// validatePet runs a pet through the checks that are passed in.\nfunc validatePet(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet, checks ...petValidator) error {\n    // TODO: Implement validation logic...\n\n    return nil\n}\n")),(0,i.kt)("p",null,"This ",(0,i.kt)("inlineCode",{parentName:"p"},"checks"),' parameter is what is known as a "variadic parameter," making this a\n',(0,i.kt)("a",{parentName:"p",href:"https://gobyexample.com/variadic-functions"},"variadic function"),". This allows us to pass in however many rules we want,\ngranting us flexibility in how we validate services, for example, using different checks depending on who is using it."),(0,i.kt)("p",null,"Let's start defining the logic for our function by adding code to loop through our validators, calling the\n",(0,i.kt)("inlineCode",{parentName:"p"},"Validate")," method on each of them: "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/validation.go"',title:'"pkg/services/pet/validation.go"'},"package pet\n\n// Previous definitions omitted to focus on the new part for now\n\n// validatePet runs a pet through the checks that are passed in.\nfunc validatePet(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet, checks ...petValidator) error {\n    for _, check := range checks {\n        if err := check.Validate(appCtx, newPet, originalPet); err != nil {\n            // TODO: Handle errors\n        }\n    }\n\n    return nil\n}\n")),(0,i.kt)("p",null,"After we call ",(0,i.kt)("inlineCode",{parentName:"p"},"Validate()"),", we must handle the error that comes back. We have a couple of guidelines for doing this:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("a",{parentName:"li",href:"https://pkg.go.dev/github.com/gobuffalo/validate"},"Go Buffalo type ",(0,i.kt)("inlineCode",{parentName:"a"},"validate.Errors"))," (commonly assigned to\n",(0,i.kt)("inlineCode",{parentName:"li"},"verrs"),") should be used to track input errors per field. We do this so the user can get as much information back as\npossible instead of only seeing one error per request.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Use ",(0,i.kt)("inlineCode",{parentName:"li"},"Add(fieldName str, Message str)")," to add individual errors to this type one at a time."),(0,i.kt)("li",{parentName:"ul"},"Use ",(0,i.kt)("inlineCode",{parentName:"li"},"Append(verrs validate.Errors)")," to combine lists of validation errors."))),(0,i.kt)("li",{parentName:"ul"},"All validation errors should be wrapped in a ",(0,i.kt)("inlineCode",{parentName:"li"},"apperror.InvalidInputError")," type when returned."),(0,i.kt)("li",{parentName:"ul"},"Any other error types are not combined and take immediate precedence over input errors. For example, the error saying\nthat the model should not have been visible to the caller will take precedence over an error about the phone number\nbeing mistyped.")),(0,i.kt)("p",null,"In order to follow these guidelines, we need to check the type of the error being returned from the validator. If\nthe error is a validation error type, we will combine it with an ongoing list of validation errors and continue\nchecking the rest of the validators."),(0,i.kt)("p",null,"If it is ",(0,i.kt)("em",{parentName:"p"},"not")," a validation error, we stop everything and return it right away."),(0,i.kt)("p",null,"Taking those guidelines into account, we end up with this ",(0,i.kt)("inlineCode",{parentName:"p"},"validatePet")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/validation.go"',title:'"pkg/services/pet/validation.go"'},'package pet\n\n// Previous definitions omitted to focus on the new part for now\n\n// validatePet runs a pet through the checks that are passed in.\nfunc validatePet(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet, checks ...petValidator) error {\n    verrs := validate.NewErrors()\n\n    for _, check := range checks {\n        if err := check.Validate(appCtx, newPet, originalPet); err != nil {\n            switch e := err.(type) {\n            case *validate.Errors:\n                // Accumulate all validation errors\n                verrs.Append(e)\n            default:\n                // Non-validation errors have priority and short-circuit doing any further checks\n                return err\n            }\n        }\n    }\n\n    if verrs.HasAny() {\n        return apperror.NewInvalidInputError(newPet.ID, nil, verrs, "Invalid input found while validating the pet.")\n    }\n\n    return nil\n}\n')),(0,i.kt)("p",null,"This function is almost entirely boilerplate and can be copied and pasted from one service to another with minimal\nchanges."),(0,i.kt)("h4",{id:"testing-validationgo"},"Testing ",(0,i.kt)("inlineCode",{parentName:"h4"},"validation.go")),(0,i.kt)("p",null,"Since most of the code is boilerplate, we can get by with just a few small tests to make sure things work as\nexpected. Here is a sample of what your tests could look like (or you can even copy these and modify to fit your\nfunction signatures):"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Sample `validation_test.go`"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/validation_test.go"',title:'"pkg/services/pet/validation_test.go"'},'package pet\n\nimport (\n    "github.com/gobuffalo/validate/v3"\n    "github.com/gofrs/uuid"\n\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/apperror"\n    "github.com/transcom/mymove/pkg/models"\n)\n\nfunc (suite PetSuite) TestPetValidatorFuncValidate() {\n    suite.Run("Calling Validate runs validation function with no errors", func() {\n        validator := petValidatorFunc(func(_ appcontext.AppContext, _ models.Pet, _ *models.Pet) error {\n            return nil\n        })\n\n        err := validator.Validate(suite.AppContextForTest(), models.Pet{}, nil)\n\n        suite.NoError(err)\n    })\n\n    suite.Run("Calling Validate runs validation function with errors", func() {\n        validator := petValidatorFunc(func(_ appcontext.AppContext, _ models.Pet, _ *models.Pet) error {\n            verrs := validate.NewErrors()\n\n            verrs.Add("ID", "fake error")\n\n            return verrs\n        })\n\n        err := validator.Validate(suite.AppContextForTest(), models.Pet{}, nil)\n\n        suite.Error(err)\n        suite.Contains(err.Error(), "fake error")\n    })\n}\n\nfunc (suite PetSuite) TestValidatePet() {\n    suite.Run("Runs validation and returns nil when there are no errors", func() {\n        checkAlwaysReturnNil := petValidatorFunc(func(_ appcontext.AppContext, _ models.Pet, _ *models.Pet) error {\n            return nil\n        })\n\n        err := validatePet(suite.AppContextForTest(), models.Pet{}, nil, []petValidator{checkAlwaysReturnNil}...)\n\n        suite.NoError(err)\n    })\n\n    suite.Run("Runs validation and returns input errors", func() {\n        checkAlwaysReturnValidationErr := petValidatorFunc(func(_ appcontext.AppContext, _ models.Pet, _ *models.Pet) error {\n            verrs := validate.NewErrors()\n\n            verrs.Add("ID", "fake error")\n\n            return verrs\n        })\n\n        err := validatePet(suite.AppContextForTest(), models.Pet{}, nil, []petValidator{checkAlwaysReturnValidationErr}...)\n\n        suite.Error(err)\n        suite.IsType(apperror.InvalidInputError{}, err)\n        suite.Contains(err.Error(), "Invalid input found while validating the pet.")\n    })\n\n    suite.Run("Runs validation and returns other errors", func() {\n        checkAlwaysReturnOtherError := petValidatorFunc(func(_ appcontext.AppContext, _ models.Pet, _ *models.Pet) error {\n            return apperror.NewNotFoundError(uuid.Must(uuid.NewV4()), "Pet not found.")\n        })\n\n        err := validatePet(suite.AppContextForTest(), models.Pet{}, nil, []petValidator{checkAlwaysReturnOtherError}...)\n\n        suite.Error(err)\n        suite.IsType(apperror.NotFoundError{}, err)\n        suite.Contains(err.Error(), "Pet not found.")\n    })\n}\n'))),(0,i.kt)("h4",{id:"final-validationgo"},"Final ",(0,i.kt)("inlineCode",{parentName:"h4"},"validation.go")),(0,i.kt)("p",null,"Just to recap, here is what our final ",(0,i.kt)("inlineCode",{parentName:"p"},"validation.go")," file looks like:"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Final `validation.go`"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/validation.go"',title:'"pkg/services/pet/validation.go"'},'package pet\n\nimport (\n    "github.com/gobuffalo/validate/v3"\n\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/apperror"\n    "github.com/transcom/mymove/pkg/models"\n)\n\n// petValidator defines the interface for checking business rules for a pet\ntype petValidator interface {\n    // Validate The newPet is assumed to be required, so that is a value type.\n    // The originalPet is optional, so it\'s a pointer type.\n    Validate(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error\n}\n\n// petValidatorFunc is an adapter that will convert a function into an implementation of petValidator\ntype petValidatorFunc func(appcontext.AppContext, models.Pet, *models.Pet) error\n\n// Validate fulfills the petValidator interface\nfunc (fn petValidatorFunc) Validate(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error {\n    return fn(appCtx, newPet, originalPet)\n}\n\n// validatePet runs a pet through the checks that are passed in.\nfunc validatePet(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet, checks ...petValidator) error {\n    verrs := validate.NewErrors()\n\n    for _, check := range checks {\n        if err := check.Validate(appCtx, newPet, originalPet); err != nil {\n            switch e := err.(type) {\n            case *validate.Errors:\n                // Accumulate all validation errors\n                verrs.Append(e)\n            default:\n                // Non-validation errors have priority and short-circuit doing any further checks\n                return err\n            }\n        }\n    }\n\n    if verrs.HasAny() {\n        return apperror.NewInvalidInputError(newPet.ID, nil, verrs, "Invalid input found while validating the pet.")\n    }\n\n    return nil\n}\n'))),(0,i.kt)("h3",{id:"rulesgo"},(0,i.kt)("inlineCode",{parentName:"h3"},"rules.go")),(0,i.kt)("p",null,"Now we'll create the ",(0,i.kt)("inlineCode",{parentName:"p"},"rules.go")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"rules_test.go")," files. In the ",(0,i.kt)("inlineCode",{parentName:"p"},"rules.go")," file, we'll use the types defined in\n",(0,i.kt)("inlineCode",{parentName:"p"},"validation.go"),", so make sure you've done that first. You'll also need to know what your business rules are."),(0,i.kt)("p",null,"For our example, here are a few potential rules (for the sake of brevity, we won't actually implement them all):"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ID")," must be blank when creating a ",(0,i.kt)("inlineCode",{parentName:"li"},"Pet"),"."),(0,i.kt)("li",{parentName:"ul"},"Check that ",(0,i.kt)("inlineCode",{parentName:"li"},"Type")," isn't an empty string."),(0,i.kt)("li",{parentName:"ul"},"Check that ",(0,i.kt)("inlineCode",{parentName:"li"},"Name")," is not empty and doesn't contain invalid characters."),(0,i.kt)("li",{parentName:"ul"},"Check that, if both ",(0,i.kt)("inlineCode",{parentName:"li"},"Birthday")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"GotchaDay")," are defined, ",(0,i.kt)("inlineCode",{parentName:"li"},"Birthday")," is equal to, or earlier than the ",(0,i.kt)("inlineCode",{parentName:"li"},"GotchaDay"),"."),(0,i.kt)("li",{parentName:"ul"},"Check that, if ",(0,i.kt)("inlineCode",{parentName:"li"},"Weight")," is defined, it is greater than 0.")),(0,i.kt)("p",null,"We'll start by defining the functions for our rules like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/rules.go"',title:'"pkg/services/pet/rules.go"'},'package pet\n\nimport (\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/models"\n)\n\nfunc checkID() petValidator {\n    return petValidatorFunc(func(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error {\n        return nil // TODO: implement validation logic\n    })\n}\n\nfunc checkType() petValidator {\n    return petValidatorFunc(func(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error {\n        return nil // TODO: implement validation logic\n    })\n}\n\nfunc checkName() petValidator {\n    return petValidatorFunc(func(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error {\n        return nil // TODO: implement validation logic\n    })\n}\n')),(0,i.kt)("p",null,"These functions are ",(0,i.kt)("a",{parentName:"p",href:"https://gobyexample.com/closures"},(0,i.kt)("strong",{parentName:"a"},"closures")),", which uses a function within a function.\nIn this case, the outer function has no parameters and returns the ",(0,i.kt)("inlineCode",{parentName:"p"},"petValidator")," interface type."),(0,i.kt)("p",null,"The ",(0,i.kt)("em",{parentName:"p"},"inner")," function, however, must have a signature that is exactly the same as our ",(0,i.kt)("inlineCode",{parentName:"p"},"petValidatorFunc")," function type so\nthat we can use the interface. This means you will have to change all of these rule functions if you ever change that\nbase signature, so keep that in mind as you continue working on validation."),(0,i.kt)("h4",{id:"checkid"},(0,i.kt)("inlineCode",{parentName:"h4"},"checkID")),(0,i.kt)("p",null,"We've defined the function name and signature, so we can write our tests for what we expect to happen (minimized for\nease of reading the page): "),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Tests for `checkID`"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/rules_test.go"',title:'"pkg/services/pet/rules_test.go"'},'package pet\n\nimport (\n    "github.com/gobuffalo/validate/v3"\n    "github.com/gofrs/uuid"\n\n    "github.com/transcom/mymove/pkg/models"\n)\n\nfunc (suite *PetSuite) TestCheckID() {\n    suite.Run("Success", func() {\n        suite.Run("Create Pet without an ID", func() {\n            err := checkID().Validate(suite.AppContextForTest(), models.Pet{}, nil)\n\n            suite.NilOrNoVerrs(err)\n        })\n\n        suite.Run("Update Pet with matching ID", func() {\n            id := uuid.Must(uuid.NewV4())\n\n            err := checkID().Validate(suite.AppContextForTest(), models.Pet{ID: id}, &models.Pet{ID: id})\n\n            suite.NilOrNoVerrs(err)\n        })\n    })\n\n    suite.Run("Failure", func() {\n        suite.Run("Return an error if an ID is defined when creating a Pet", func() {\n            err := checkID().Validate(suite.AppContextForTest(), models.Pet{ID: uuid.Must(uuid.NewV4())}, nil)\n\n            suite.Error(err)\n            suite.IsType(&validate.Errors{}, err)\n            suite.Contains(err.Error(), "when creating a Pet ID must not be set")\n        })\n\n        suite.Run("Return an error if the IDs don\'t match", func() {\n            err := checkID().Validate(suite.AppContextForTest(), models.Pet{ID: uuid.Must(uuid.NewV4())}, &models.Pet{ID: uuid.Must(uuid.NewV4())})\n\n            suite.Error(err)\n            suite.IsType(&validate.Errors{}, err)\n            suite.Contains(err.Error(), "new Pet ID must match original Pet ID")\n        })\n    })\n}\n'))),(0,i.kt)("p",null,"Now we can implement the function like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/rules.go" {13,14}',title:'"pkg/services/pet/rules.go"',"{13,14}":!0},'package pet\n\nimport (\n    "github.com/gobuffalo/validate/v3"\n\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/models"\n)\n\n// checkID checks that newPet doesn\'t already have an ID if we\'re creating a Pet, or that it matches the original Pet\n// for updates.\nfunc checkID() petValidator {\n    return petValidatorFunc(func(_ appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error {\n        verrs := validate.NewErrors()\n\n        if originalPet == nil {\n            if newPet.ID.IsNil() {\n                return verrs\n            }\n\n            verrs.Add("ID", "when creating a Pet ID must not be set")\n        } else {\n            if newPet.ID != originalPet.ID {\n                verrs.Add("ID", "new Pet ID must match original Pet ID")\n            }\n        }\n\n        return verrs\n    })\n}\n')),(0,i.kt)("p",null,"You may notice we use ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," for the ",(0,i.kt)("inlineCode",{parentName:"p"},"appcontext.AppContext")," param since we don't need it for this rule. Since we need\na verbose signature to fit our needs for ",(0,i.kt)("em",{parentName:"p"},"all")," of these rules, there is no way we're going to use everything in\nevery single rule. Use ",(0,i.kt)("inlineCode",{parentName:"p"},"_")," to make clear what is relevant and what isn't."),(0,i.kt)("p",null,"You can also see that we start the inner function off by initializing ",(0,i.kt)("inlineCode",{parentName:"p"},"verrs")," to hold our validation errors. We\nalways return this at the end of our rule functions."),(0,i.kt)("h4",{id:"checktype"},(0,i.kt)("inlineCode",{parentName:"h4"},"checkType")),(0,i.kt)("p",null,"Based on our business rules, we want to make sure that ",(0,i.kt)("inlineCode",{parentName:"p"},"Pet.Type")," is always set. We set up the model and table such\nthat only a few values are valid, but the way the model works, it still allows a blank string to be set, so we want\nto check for that. Our tests for this one will look like this (minimized for ease of reading the page):"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Tests for `checkType`"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/rules_test.go"',title:'"pkg/services/pet/rules_test.go"'},'package pet\n\nimport (\n    "github.com/gobuffalo/validate/v3"\n    "github.com/gofrs/uuid"\n\n    "github.com/transcom/mymove/pkg/models"\n)\n\n// TestCheckID tests omitted for clarity\n\nfunc (suite *PetSuite) TestCheckType() {\n    suite.Run("Success", func() {\n        suite.Run("Create Pet", func() {\n            err := checkType().Validate(\n                suite.AppContextForTest(),\n                models.Pet{\n                    Type: models.PetTypeCat,\n                    Name: "Fluffy",\n                },\n                nil,\n            )\n\n            suite.NilOrNoVerrs(err)\n        })\n\n        suite.Run("Update Pet", func() {\n            err := checkType().Validate(\n                suite.AppContextForTest(),\n                models.Pet{\n                    Type: models.PetTypeDog,\n                },\n                &models.Pet{\n                    ID:   uuid.Must(uuid.NewV4()),\n                    Type: models.PetTypeCat,\n                    Name: "Fluffy",\n                },\n            )\n\n            suite.NilOrNoVerrs(err)\n        })\n    })\n\n    suite.Run("Failure", func() {\n        suite.Run("Return an error for an empty pet type", func() {\n            err := checkType().Validate(\n                suite.AppContextForTest(),\n                models.Pet{\n                    Name: "Fluffy",\n                },\n                nil,\n            )\n\n            suite.Error(err)\n            suite.IsType(&validate.Errors{}, err)\n            suite.Contains(err.Error(), "type of pet must be specified")\n        })\n    })\n}\n'))),(0,i.kt)("p",null,"Now we can implement the function like so:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/rules.go" {13,14}',title:'"pkg/services/pet/rules.go"',"{13,14}":!0},'package pet\n\nimport (\n    "github.com/gobuffalo/validate/v3"\n\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/models"\n)\n\n\n// other check functions omitted to focus on checkType\n\n// checkType checks that newPet.Type is not an empty string.\nfunc checkType() petValidator {\n    return petValidatorFunc(func(_ appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error {\n        verrs := validate.NewErrors()\n\n        if newPet.Type == "" {\n            verrs.Add("Type", "type of pet must be specified")\n        }\n\n        return verrs\n    })\n}\n')),(0,i.kt)("h4",{id:"checkname"},(0,i.kt)("inlineCode",{parentName:"h4"},"checkName")),(0,i.kt)("p",null,"For this one, we'll take advantage of the fact that we're using ",(0,i.kt)("inlineCode",{parentName:"p"},"closures"),"."),(0,i.kt)("p",null,"Let's pretend that we have a service that we use to check strings to make sure they don't have invalid characters\n(e.g. strings that could be used run malicious code). Imagine the service interface looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/string_checker.go"',title:'"pkg/services/string_checker.go"'},'package services\n\nimport (\n    "github.com/transcom/mymove/pkg/appcontext"\n)\n\n// StringChecker validates a string of text to make sure it is safe\n//go:generate mockery --name StringChecker --disable-version-string\ntype StringChecker interface {\n    Validate(appCtx appcontext.AppContext, text string) error\n}\n')),(0,i.kt)("p",null,"We haven't covered how you're supposed to use service objects, but the important points to know for now are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"To define something as using this service object's type, we would use ",(0,i.kt)("inlineCode",{parentName:"li"},"services.StringChecker")),(0,i.kt)("li",{parentName:"ul"},"To mock it out in tests, you can use",(0,i.kt)("inlineCode",{parentName:"li"},"mocks.NewStringChecker(suite.T())"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"This will give you a pointer to the mock and set it up so that when the test is cleaning up, it will assert\nany expectations you set up actually happened (i.e. if you said it will be called with xyz, it will verify it\nwas called with that).  "))),(0,i.kt)("li",{parentName:"ul"},"To use it in our service, we'll define a parameter like this: ",(0,i.kt)("inlineCode",{parentName:"li"},"stringChecker services.StringChecker"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"We then use it like this: ",(0,i.kt)("inlineCode",{parentName:"li"},'err := stringChecker(appCtx, "my string to check")'))))),(0,i.kt)("p",null,"We'll see all this in practice next."),(0,i.kt)("p",null,"Now let's say we want to run every name that gets input through our string checker to make sure that users aren't\npassing in bad characters or strings. We can do this by updating our definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"checkName")," to look like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/rules.go" {9}',title:'"pkg/services/pet/rules.go"',"{9}":!0},'package pet\n\nimport (\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// other check functions omitted to focus on checkName\n\n// checkName checks that a name has been input or that one is already set, and runs the string through a string checker\n// service.\nfunc checkName(stringChecker services.StringChecker) petValidator {\n    return petValidatorFunc(func(_ appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error {\n        return nil // TODO: implement validation logic\n    })\n}\n')),(0,i.kt)("p",null,"Note how we added ",(0,i.kt)("inlineCode",{parentName:"p"},"stringChecker services.StringChecker")," as a parameter to ",(0,i.kt)("inlineCode",{parentName:"p"},"checkName"),", the outer function. Since\nwe're using ",(0,i.kt)("inlineCode",{parentName:"p"},"closures"),", we'll be able to use this ",(0,i.kt)("inlineCode",{parentName:"p"},"StringChecker")," service in the inner function, without having to\nchange the signature of the inner function (and by extension every other validation function)."),(0,i.kt)("p",null,"With our newly updated function signature, we're ready to write our tests!"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Tests for `checkID`"),(0,i.kt)("p",null,"We'll go into more detail on how we're using the mocks later, but the main thing to get from this for now is that we\nwant to ensure:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A pet has a name. This means either a new name is set, or the new name matches the old name."),(0,i.kt)("li",{parentName:"ul"},"A new name has no invalid characters.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/rules_test.go"',title:'"pkg/services/pet/rules_test.go"'},'package pet\n\nimport (\n    "errors"\n    "fmt"\n    \n    "github.com/gobuffalo/validate/v3"\n    "github.com/gofrs/uuid"\n    "github.com/stretchr/testify/mock"\n\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services/mocks"\n)\n\n// TestCheckID and TestCheckType tests omitted for clarity\n\nfunc (suite *PetSuite) TestCheckName() {\n    getMockStringChecker := func(willBeUsed bool, err error) *mocks.StringChecker {\n        stringChecker := mocks.NewStringChecker(suite.T())\n\n        if willBeUsed {\n            stringChecker.On("Validate",\n                mock.AnythingOfType("*appcontext.appContext"),\n                mock.AnythingOfType("string"),\n            ).Return(err)\n        }\n\n        return stringChecker\n    }\n\n    suite.Run("Success", func() {\n        newName := "Luna"\n        oldName := "Whiskers"\n\n        suite.Run("Create Pet", func() {\n            stringChecker := getMockStringChecker(true, nil)\n\n            err := checkName(stringChecker).Validate(\n                suite.AppContextForTest(),\n                models.Pet{Name: newName},\n                nil,\n            )\n\n            suite.NilOrNoVerrs(err)\n        })\n\n        suite.Run("Update Pet", func() {\n            petID := uuid.Must(uuid.NewV4())\n\n            stringChecker := getMockStringChecker(true, nil)\n\n            err := checkName(stringChecker).Validate(\n                suite.AppContextForTest(),\n                models.Pet{\n                    ID:   petID,\n                    Name: newName,\n                },\n                &models.Pet{\n                    ID:   petID,\n                    Name: oldName,\n                },\n            )\n\n            suite.NilOrNoVerrs(err)\n        })\n\n        suite.Run("Update with no name change", func() {\n            petID := uuid.Must(uuid.NewV4())\n\n            stringChecker := getMockStringChecker(false, nil)\n\n            err := checkName(stringChecker).Validate(\n                suite.AppContextForTest(),\n                models.Pet{\n                    ID:   petID,\n                    Name: oldName,\n                },\n                &models.Pet{\n                    ID:   petID,\n                    Name: oldName,\n                },\n            )\n\n            suite.NilOrNoVerrs(err)\n        })\n    })\n\n    suite.Run("Failure", func() {\n        blankNameError := errors.New("pet name must be defined")\n        stringCheckError := errors.New("invalid characters found in string")\n        invalidName := "<hacked>"\n\n        invalidCases := map[string]struct {\n            newPetName  string\n            originalPet *models.Pet\n            expectedErr error\n        }{\n            "creating with no name": {\n                "",\n                nil,\n                blankNameError,\n            },\n            "creating with invalid name": {\n                invalidName,\n                nil,\n                stringCheckError,\n            },\n            "updating with invalid name": {\n                invalidName,\n                &models.Pet{\n                    ID:   uuid.Must(uuid.NewV4()),\n                    Name: "Whiskers",\n                },\n                stringCheckError,\n            },\n        }\n\n        for tc, testData := range invalidCases {\n            tc := tc\n            testData := testData\n\n            suite.Run(fmt.Sprintf("Return error for an invalid name when %v", tc), func() {\n                stringChecker := getMockStringChecker(testData.newPetName != "", stringCheckError)\n\n                newPet := models.Pet{Name: testData.newPetName}\n\n                if testData.originalPet != nil {\n                    newPet.ID = testData.originalPet.ID\n                }\n\n                err := checkName(stringChecker).Validate(\n                    suite.AppContextForTest(),\n                    newPet,\n                    testData.originalPet,\n                )\n\n                suite.Error(err)\n                suite.IsType(&validate.Errors{}, err)\n                suite.Contains(err.Error(), testData.expectedErr.Error())\n            })\n        }\n    })\n}\n'))),(0,i.kt)("p",null,"Now we can implement our ",(0,i.kt)("inlineCode",{parentName:"p"},"checkName")," function:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/rules.go"',title:'"pkg/services/pet/rules.go"'},'package pet\n\nimport (\n    "github.com/gobuffalo/validate/v3"\n\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// other check functions omitted to focus on checkName\n\n// checkName checks that a name has been input or that one is already set, and runs the string through a string checker\n// service.\nfunc checkName(stringChecker services.StringChecker) petValidator {\n    return petValidatorFunc(func(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error {\n        verrs := validate.NewErrors()\n\n        if newPet.Name == "" {\n            verrs.Add("Name", "pet name must be defined")\n\n            return verrs\n        }\n\n        if originalPet != nil && newPet.Name == originalPet.Name {\n            return verrs\n        }\n\n        err := stringChecker.Validate(appCtx, newPet.Name)\n\n        if err != nil {\n            verrs.Add("Name", err.Error())\n        }\n\n        return verrs\n    })\n}\n')),(0,i.kt)("p",null,"As stated earlier, we're able to pass in the ",(0,i.kt)("inlineCode",{parentName:"p"},"services.StringChecker")," in to the outer function and then use it in\nthe inner function. "),(0,i.kt)("p",null,"This then leads to a question: What should go in the validator signature (inner function) and what goes in the\nsignature of the outer function?"),(0,i.kt)("p",null,"There is a lot of room for interpretation with this, but some general guidelines are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If it's a dependency that can be set up before the service function is called, pass it in as the input of the outer\nfunction."),(0,i.kt)("li",{parentName:"ul"},"If it's data that ",(0,i.kt)("em",{parentName:"li"},"must")," be retrieved ",(0,i.kt)("em",{parentName:"li"},"during")," the service function, it should be in the validator function signature.")),(0,i.kt)("p",null,"The parameters in the outer functions are like ",(0,i.kt)("em",{parentName:"p"},"dependencies"),", and the validator function signature is the true input."),(0,i.kt)("h4",{id:"grouping-rules-functions"},"Grouping ",(0,i.kt)("inlineCode",{parentName:"h4"},"rules")," Functions"),(0,i.kt)("p",null,"Once we have some rules, we can start grouping them as needed. For example, we could group them based on which set\nof users require different rules. The key here is to define functions that will return slices of validator functions,\ninstead of constant slice variables."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/rules.go"',title:'"pkg/services/pet/rules.go"'},"package pet\n\n// Other logic left out for brevity.\n\n// customerChecks are the rules that should run for actions taken by customers\nfunc customerChecks(stringChecker services.StringChecker) []petValidator {\n    return []petValidator{\n        checkID(),\n        checkType(),\n        checkName(stringChecker),\n    }\n}\n\n// officeChecks are the rules that should run for actions taken by office users\nfunc officeChecks() []petValidator {\n    return []petValidator{\n        checkID(),\n        checkType(),\n    }\n}\n")),(0,i.kt)("p",null,"The power of this pattern is that it lets us easily define that for customers, we want to check the Pet names, but\nwe'll let office users input whatever they want for names. "),(0,i.kt)("p",null,"You'll notice that we're calling our ",(0,i.kt)("inlineCode",{parentName:"p"},"check<thing>")," functions now, but this isn't triggering validation. These are\n",(0,i.kt)("inlineCode",{parentName:"p"},"closures"),", so we're calling the outer function, which is returning our validator. The validators that we get back\naren't called until ",(0,i.kt)("inlineCode",{parentName:"p"},"validatePet")," is called."),(0,i.kt)("p",null,"Note that we ",(0,i.kt)("em",{parentName:"p"},"do"),' pass in whatever parameters we use in the outer functions at this level. This is where we set those\n"dependencies".'),(0,i.kt)("p",null,"These grouping functions can be used in multiple places, and are meant for utility. They are not a hard requirement to\nimplement the validator pattern, but they are helpful organizational tools."),(0,i.kt)("h4",{id:"final-rulesgo"},"Final ",(0,i.kt)("inlineCode",{parentName:"h4"},"rules.go")),(0,i.kt)("p",null,"Here is the final rules file that we have:"),(0,i.kt)("details",null,(0,i.kt)("summary",null,"Final `rules.go` file"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/rules.go"',title:'"pkg/services/pet/rules.go"'},'package pet\n\nimport (\n    "github.com/gobuffalo/validate/v3"\n\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// checkID checks that newPet doesn\'t already have an ID if we\'re creating a Pet, or that it matches the original Pet\n// for updates.\nfunc checkID() petValidator {\n    return petValidatorFunc(func(_ appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error {\n        verrs := validate.NewErrors()\n\n        if originalPet == nil {\n            if newPet.ID.IsNil() {\n                return verrs\n            }\n\n            verrs.Add("ID", "ID must not be set when creating a Pet.")\n        } else {\n            if newPet.ID != originalPet.ID {\n                verrs.Add("ID", "ID for new Pet must match original Pet ID.")\n            }\n        }\n\n        return verrs\n    })\n}\n\n// checkType checks that newPet.Type is not an empty string.\nfunc checkType() petValidator {\n    return petValidatorFunc(func(_ appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error {\n        verrs := validate.NewErrors()\n\n        if newPet.Type == "" {\n            verrs.Add("Type", "Type of pet must be specified.")\n        }\n\n        return verrs\n    })\n}\n\n// checkName checks that a name has been input or that one is already set, and runs the string through a string checker\n// service.\nfunc checkName(stringChecker services.StringChecker) petValidator {\n    return petValidatorFunc(func(appCtx appcontext.AppContext, newPet models.Pet, originalPet *models.Pet) error {\n        verrs := validate.NewErrors()\n\n        if newPet.Name == "" {\n            verrs.Add("Name", "Pet name must be defined.")\n\n            return verrs\n        }\n\n        if originalPet != nil && newPet.Name == originalPet.Name {\n            return verrs\n        }\n\n        err := stringChecker.Validate(appCtx, newPet.Name)\n\n        if err != nil {\n            verrs.Add("Name", err.Error())\n        }\n\n        return verrs\n    })\n}\n\n// customerChecks are the rules that should run for actions taken by customers\nfunc customerChecks(stringChecker services.StringChecker) []petValidator {\n    return []petValidator{\n        checkID(),\n        checkType(),\n        checkName(stringChecker),\n    }\n}\n\n// officeChecks are the rules that should run for actions taken by office users\nfunc officeChecks() []petValidator {\n    return []petValidator{\n        checkID(),\n        checkType(),\n    }\n}\n'))),(0,i.kt)("h2",{id:"recap"},"Recap"),(0,i.kt)("p",null,"So now we've written rules for what validation we expect to happen with our data, and we've set up the validation\nfunction that we can call to run through those rules. Now you can move on to setting up the actual service object."),(0,i.kt)("h2",{id:"examples"},"Examples"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Shipment Orchestrator",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/transcom/mymove/blob/main/pkg/services/orchestrators/shipment/rules.go"},"https://github.com/transcom/mymove/blob/main/pkg/services/orchestrators/shipment/rules.go")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/transcom/mymove/blob/main/pkg/services/orchestrators/shipment/validation.go"},"https://github.com/transcom/mymove/blob/main/pkg/services/orchestrators/shipment/validation.go")))),(0,i.kt)("li",{parentName:"ul"},"PPMShipments",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/transcom/mymove/blob/main/pkg/services/ppmshipment/rules.go"},"https://github.com/transcom/mymove/blob/main/pkg/services/ppmshipment/rules.go")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/transcom/mymove/blob/main/pkg/services/ppmshipment/validation.go"},"https://github.com/transcom/mymove/blob/main/pkg/services/ppmshipment/validation.go")))),(0,i.kt)("li",{parentName:"ul"},"Reweighs",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/transcom/mymove/blob/main/pkg/services/reweigh/rules.go"},"https://github.com/transcom/mymove/blob/main/pkg/services/reweigh/rules.go")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/transcom/mymove/blob/main/pkg/services/reweigh/validation.go"},"https://github.com/transcom/mymove/blob/main/pkg/services/reweigh/validation.go"))))),(0,i.kt)("h2",{id:"resources"},"Resources"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Interfaces",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gobyexample.com/interfaces"},"Go by Example: Interfaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://golangbot.com/interfaces-part-1/"},"Interfaces in Go")))),(0,i.kt)("li",{parentName:"ul"},"Function types",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://stackoverflow.com/questions/9398739/working-with-function-types-in-go"},"Working with function types in Go")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://yourbasic.org/golang/function-pointer-type-declaration/"},"Function types and values")))),(0,i.kt)("li",{parentName:"ul"},"Variadic functions",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gobyexample.com/variadic-functions"},"Go by Example: Variadic Functions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://golangbot.com/variadic-functions/"},"Variadic Functions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.digitalocean.com/community/tutorials/how-to-use-variadic-functions-in-go"},"How to use variadic functions in Go")))),(0,i.kt)("li",{parentName:"ul"},"Closures",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://stackoverflow.com/a/7464475"},"What is a closure")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://betterprogramming.pub/closures-made-simple-with-golang-69db3017cd7b"},"Closures in Go")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://gobyexample.com/closures"},"Go by Example: Closures")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.calhoun.io/5-useful-ways-to-use-closures-in-go/"},"5 useful ways to use closures in Go"))))))}d.isMDXComponent=!0}}]);