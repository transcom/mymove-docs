"use strict";(self.webpackChunkmymove_docs=self.webpackChunkmymove_docs||[]).push([[6014],{54586:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>m,frontMatter:()=>s,metadata:()=>l,toc:()=>d});var i=n(87462),a=(n(67294),n(3905));n(8209);const s={title:"0045 Nesting Swagger paths in the Prime API with multiple IDs"},o="Nesting Swagger paths in the Prime API with multiple IDs",l={unversionedId:"adrs/nesting-swagger-paths",id:"adrs/nesting-swagger-paths",title:"0045 Nesting Swagger paths in the Prime API with multiple IDs",description:"The Prime API manages Move Task Orders and the child objects for these orders, such as shipments and payment requests.",source:"@site/docs/adrs/0045-nesting-swagger-paths.md",sourceDirName:"adrs",slug:"/adrs/nesting-swagger-paths",permalink:"/mymove-docs/docs/adrs/nesting-swagger-paths",draft:!1,editUrl:"https://github.com/transcom/mymove-docs/edit/main/docs/adrs/0045-nesting-swagger-paths.md",tags:[],version:"current",sidebarPosition:45,frontMatter:{title:"0045 Nesting Swagger paths in the Prime API with multiple IDs"},sidebar:"adrsSidebar",previous:{title:"0044 Use camelCase for API params",permalink:"/mymove-docs/docs/adrs/params-styling"},next:{title:"0046 Use nodenv to manage Node versions in development",permalink:"/mymove-docs/docs/adrs/use-nodenv"}},r={},d=[{value:"Considered Alternatives",id:"considered-alternatives",level:2},{value:"Decision Outcome",id:"decision-outcome",level:2},{value:"Chosen Alternative: <em>Do not include multiple IDs unless functionally necessary</em>",id:"chosen-alternative-do-not-include-multiple-ids-unless-functionally-necessary",level:3},{value:"Pros and Cons of the Alternatives",id:"pros-and-cons-of-the-alternatives",level:2},{value:"<em>Leave the codebase as-is</em>",id:"leave-the-codebase-as-is",level:3},{value:"<em>Nest all paths with the IDs of the parent objects</em>",id:"nest-all-paths-with-the-ids-of-the-parent-objects",level:3},{value:"<em>Do not include multiple IDs unless functionally necessary. Start a new root uniquely identifiable objects</em>",id:"do-not-include-multiple-ids-unless-functionally-necessary-start-a-new-root-uniquely-identifiable-objects",level:3}],h={toc:d},p="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,i.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"nesting-swagger-paths-in-the-prime-api-with-multiple-ids"},"Nesting Swagger paths in the Prime API with multiple IDs"),(0,a.kt)("p",null,"The Prime API manages Move Task Orders and the child objects for these orders, such as shipments and payment requests.\nThe relationship between these objects is a straight-forward Many-to-One (many shipments or payment requests\nto one MTO), and the IDs for the child objects can be used alone to uniquely identify a record. The endpoints for this\nAPI follow a standard pattern of basing updates and reads off of one record at a time (sometimes returning multiple\nrecords when children of the base object are included). When writing the paths for these endpoints, two distinct\nstrategies have been used:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Nest the path for the new endpoint by including the ID of the parent Move Task Order for the object, e.g.\n",(0,a.kt)("inlineCode",{parentName:"li"},"/move-task-orders/{moveTaskOrderID}/mto-shipments/{mtoShipmentID}")),(0,a.kt)("li",{parentName:"ol"},"Do not nest under the parent MTO and only include the ID of the object being accessed in the path, e.g.\n",(0,a.kt)("inlineCode",{parentName:"li"},"/payment-requests/{paymentRequestID}"))),(0,a.kt)("p",null,"The first strategy is problematic because the ",(0,a.kt)("inlineCode",{parentName:"p"},"moveTaskOrderID")," in the path is not validated, so there is no meaningful\nconnection between that value and the ID of the child object. Only the ID of the child object - the ",(0,a.kt)("inlineCode",{parentName:"p"},"mtoShipmentID")," in\nthis example - is needed to fetch, validate, and update the record. The UUIDs also make the paths extremely long."),(0,a.kt)("p",null,"The second strategy is problematic because it is inconsistent with the other the endpoints. It also obfuscates the\nrelationships between objects."),(0,a.kt)("p",null,"Ultimately, the question is whether or not we should be including IDs that are functionally unnecessary in the path for\nthe sake of a clear hierarchical structure in the API. This ADR sets this question within the context of the Prime API,\nbut aims to propose a generic solution that is acceptable for most other APIs as well."),(0,a.kt)("h2",{id:"considered-alternatives"},"Considered Alternatives"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Leave the codebase as-is"),(0,a.kt)("li",{parentName:"ul"},"Nest all paths with the IDs of the parent objects"),(0,a.kt)("li",{parentName:"ul"},"Do not include multiple IDs unless functionally necessary. Start a new root for an object that is uniquely\nidentifiable by one ID.")),(0,a.kt)("h2",{id:"decision-outcome"},"Decision Outcome"),(0,a.kt)("h3",{id:"chosen-alternative-do-not-include-multiple-ids-unless-functionally-necessary"},"Chosen Alternative: ",(0,a.kt)("em",{parentName:"h3"},"Do not include multiple IDs unless functionally necessary")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Justification:")," Philosophically, we should not require input that is unnecessary for our processing. In the Prime\nAPI, we can grab all the information we need for security and general validation using the UUID of the child object.\nRequiring extra IDs in the paths for the endpoints therefore becomes an aesthetic decision, and provides little benefit\nto the usability of the API. The clarity it provides to object relationships could (and perhaps should) be subsumed into\na well-documented ERD.")),(0,a.kt)("p",null,"Functionally, using a new root for accessing each object simplifies the endpoint paths dramatically. It also eliminates\nthe overhead of having to grab more ID values for testing and the burden of validating those values in handlers.\nFurthermore, because we already tag the endpoints with the object type being accessed, the structure of the generated\nSwagger docs should not change."),(0,a.kt)("p",null,"For example, given the two endpoints:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"  '/move-task-orders/{moveTaskOrderID}/mto-shipments/{mtoShipmentID}':\n    put:\n      consumes:\n        - application/json\n      produces:\n        - application/json\n      summary: Updates mto shipment\n      operationId: updateMTOShipment\n      tags:\n        - mtoShipment\n      parameters:\n        - in: path\n          name: moveTaskOrderID\n          required: true\n          format: uuid\n          type: string\n        - in: path\n          name: mtoShipmentID\n          required: true\n          format: uuid\n          type: string\n        - in: body\n          name: body\n          required: true\n          schema:\n            $ref: '#/definitions/MTOShipment'\n        - in: header\n          name: If-Match\n          type: string\n          required: true\n      responses:\n        [...]\n  '/move-task-orders/{moveTaskOrderID}/mto-shipments/{mtoShipmentID}/mto-service-items':\n    post:\n      consumes:\n        - application/json\n      produces:\n        - application/json\n      summary: Creates mto service items\n      operationId: createMTOServiceItem\n      tags:\n        - mtoServiceItem\n      parameters:\n        - in: path\n          name: moveTaskOrderID\n          required: true\n          format: uuid\n          type: string\n        - in: path\n          name: mtoShipmentID\n          required: true\n          format: uuid\n          type: string\n        - in: body\n          name: body\n          schema:\n            description: This may be a MTOServiceItemBasic, MTOServiceItemOriginSIT or etc.\n            $ref: '#/definitions/MTOServiceItem'\n      responses:\n        [...]\n")),(0,a.kt)("p",null,"Because of the different values in the ",(0,a.kt)("inlineCode",{parentName:"p"},"tags")," attribute, they will be grouped separately in the generated docs despite\nthe detailed nesting in the path."),(0,a.kt)("p",null,"Therefore, in this context, writing an endpoint path like"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"/child-object/{:childID}")),(0,a.kt)("p",null,"is functionally and structurally congruent to"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"/parent-object/{:parentID}/child-object/{:childID}"),","),(0,a.kt)("p",null,"and the former benefits from more simplicity and ease of use."),(0,a.kt)("p",null,"It is important to note that this endpoint structure is only valid because of the Many-to-One relationship of these\nobjects. For an API being designed with different data models, such as a Many-to-Many relationship that might need to be\nrepresented with a query like the following:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT mto_shipments.id, mto_shipments.move_task_order_id, move_task_orders.available_to_prime\nFROM mto_shipments\nJOIN move_task_orders ON move_task_orders.id = mto_shipments.move_task_order_id\nWHERE mto_shipments.id = id_from_path\nAND mto_shipments.move_task_order_id = mto_id_from_path\n")),(0,a.kt)("p",null,"it may indeed be necessary to include both IDs in the path. As such, this ADR is making the distinction that endpoint\npaths should not be nested with IDs ",(0,a.kt)("em",{parentName:"p"},"that are not functionally necessary for security, validation, or retrieval.")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"Consequences:")," All existing nested endpoints will need the following updates:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"The path and the parameter attributes in the .yaml file will need changes"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"/gen/")," code will need to be regenerated"),(0,a.kt)("li",{parentName:"ul"},"Integration tests will need changes"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"/cmd/")," code for the API CLI will need changes"),(0,a.kt)("li",{parentName:"ul"},"Handlers may not need changes, but all modified endpoints will need to be retested")))),(0,a.kt)("h2",{id:"pros-and-cons-of-the-alternatives"},"Pros and Cons of the Alternatives"),(0,a.kt)("h3",{id:"leave-the-codebase-as-is"},(0,a.kt)("em",{parentName:"h3"},"Leave the codebase as-is")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"+")," Less work now"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-")," Endpoints are inconsistent"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-")," MTO IDs for shipments are still not being validated"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-")," Future developers will not know which convention to use")),(0,a.kt)("h3",{id:"nest-all-paths-with-the-ids-of-the-parent-objects"},(0,a.kt)("em",{parentName:"h3"},"Nest all paths with the IDs of the parent objects")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"+")," Object relationships are explicit and clear to anyone using the API"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"+")," Provides an extra value to double-check that the correct record is being updated"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-")," Parent ID value is functionally irrelevant for identifying the correct record and presents an extra failure point\nfor user input"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-")," Paths with multiple UUIDs quickly become long and unwieldy"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-")," Development burden to validate that the parent ID matches the child's ID"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-")," Testing burden to always require the parent ID")),(0,a.kt)("h3",{id:"do-not-include-multiple-ids-unless-functionally-necessary-start-a-new-root-uniquely-identifiable-objects"},(0,a.kt)("em",{parentName:"h3"},"Do not include multiple IDs unless functionally necessary. Start a new root uniquely identifiable objects")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"+")," Endpoint paths are simpler and more readable"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"+")," Less input required from the user"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"+")," Security can be handled discretely in the handlers"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"+")," It's clear which object is being accessed and updated, or what the base object is (for lists)"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-")," Relationships between objects is unclear in the yaml file"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"-")," Requires a specific data model to be effective")))}m.isMDXComponent=!0}}]);