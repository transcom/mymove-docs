"use strict";(self.webpackChunkmymove_docs=self.webpackChunkmymove_docs||[]).push([[573],{70160:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>g});var a=t(58168),i=(t(96540),t(15680));t(41873);const r={sidebar_position:5},o="Creating an API",l={unversionedId:"api/guides/guide-to-creating-an-api",id:"api/guides/guide-to-creating-an-api",title:"Creating an API",description:"These are the various steps that are involved in creating a new endpoint.",source:"@site/docs/api/guides/guide-to-creating-an-api.md",sourceDirName:"api/guides",slug:"/api/guides/guide-to-creating-an-api",permalink:"/mymove-docs/docs/api/guides/guide-to-creating-an-api",draft:!1,editUrl:"https://github.com/transcom/mymove-docs/edit/main/docs/api/guides/guide-to-creating-an-api.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"apiSidebar",previous:{title:"Creating an Endpoint",permalink:"/mymove-docs/docs/api/guides/guide-to-creating-an-endpoint"},next:{title:"How to Deprecate an API Endpoint",permalink:"/mymove-docs/docs/api/guides/how-to-deprecate-endpoints"}},s={},g=[{value:"These are the various steps that are involved in creating a new endpoint.",id:"these-are-the-various-steps-that-are-involved-in-creating-a-new-endpoint",level:6},{value:"Creating a new API yaml",id:"creating-a-new-api-yaml",level:2},{value:"Creating a new API html",id:"creating-a-new-api-html",level:2},{value:"Generating swagger code for your API",id:"generating-swagger-code-for-your-api",level:2},{value:"Creating your API handler",id:"creating-your-api-handler",level:2},{value:"MilMove servers",id:"milmove-servers",level:2},{value:"Mounting your API to an existing server",id:"mounting-your-api-to-an-existing-server",level:2},{value:"Creating a proxy for your API",id:"creating-a-proxy-for-your-api",level:2},{value:"Creating your API test",id:"creating-your-api-test",level:2},{value:"Manually testing your API",id:"manually-testing-your-api",level:2},{value:"Related:",id:"related",level:2}],p={toc:g},u="wrapper";function d(e){let{components:n,...t}=e;return(0,i.yg)(u,(0,a.A)({},p,t,{components:n,mdxType:"MDXLayout"}),(0,i.yg)("h1",{id:"creating-an-api"},"Creating an API"),(0,i.yg)("h6",{id:"these-are-the-various-steps-that-are-involved-in-creating-a-new-endpoint"},"These are the various steps that are involved in creating a new endpoint."),(0,i.yg)("admonition",{type:"note"},(0,i.yg)("p",{parentName:"admonition"},"This is assumed you are creating a new API router on an existing server, this documentation will not cover how to create a new server. ")),(0,i.yg)("p",null,"Prior to creating a new API, we must first implement the swagger definition of said new API. We are using Swagger 2.0, which is ",(0,i.yg)("a",{parentName:"p",href:"https://swagger.io/specification/v2/"},"OpenAPI"),", a specification we use to format our RESTful APIs and provide a template for us to communicate the information in our API.\nAlways start with swagger. This step creates your API's endpoint definitions and generates the files and helper functions you will need to create your endpoint. More specifically, swagger converts JSON user input into generated Go types."),(0,i.yg)("h2",{id:"creating-a-new-api-yaml"},"Creating a new API yaml"),(0,i.yg)("p",null,"All new API require a new yaml file to be added in ",(0,i.yg)("inlineCode",{parentName:"p"},"mymove/swagger-def"),". This directory holds many different specs and definitions as they get reused throughout the application.\nYou will notice that there is also a ",(0,i.yg)("inlineCode",{parentName:"p"},"mymove/swagger")," folder which holds what looks to be a copy of ",(0,i.yg)("inlineCode",{parentName:"p"},"swagger-def"),", please do not edit within this folder. The ",(0,i.yg)("inlineCode",{parentName:"p"},"swagger")," folder\nholds the generated specs to be used within the backend of the codebase.\nAfter we have a base ",(0,i.yg)("inlineCode",{parentName:"p"},".yaml")," file for our new API and maybe even some tags and paths defined, we will generate Swagger and the new API definitions and specs will generated and be placed inside the ",(0,i.yg)("inlineCode",{parentName:"p"},"swagger")," folder."),(0,i.yg)("p",null,"First, create a your new API.yaml file under ",(0,i.yg)("inlineCode",{parentName:"p"},"mymove/swagger-def"),", similar to how ",(0,i.yg)("inlineCode",{parentName:"p"},"admin.yaml"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"prime.yaml"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"support.yaml"),", etc. are present. Populate your new ",(0,i.yg)("inlineCode",{parentName:"p"},".yaml")," file with this template info:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"swagger: '2.0'\ninfo:\n  title: MilMove ${API_NAME} API\n  version: 1.0.0\n  license:\n    name: MIT\n    url: 'https://opensource.org/licenses/MIT'\n  contact:\n    email: milmove-developers@caci.com\n  description:\n    ${INSERT_DESCRIPTION}\nbasePath: ${API_NAME}/v1\nconsumes:\n  - application/json\nproduces:\n  - application/json\nschemes:\n  - ${http or https}\n")),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Populate ",(0,i.yg)("inlineCode",{parentName:"li"},"${API_NAME}")," with the name of your new API"),(0,i.yg)("li",{parentName:"ul"},"Populate ",(0,i.yg)("inlineCode",{parentName:"li"},"${INSERT_DESCRIPTION}")," with a description of your new API, or conversely create a new markdown file and reference it with ",(0,i.yg)("inlineCode",{parentName:"li"},"$ref: info/${API_NAME}_description.md")),(0,i.yg)("li",{parentName:"ul"},"Populate ",(0,i.yg)("inlineCode",{parentName:"li"},"${http or https}"),(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"Populate with ",(0,i.yg)("inlineCode",{parentName:"li"},"http")," for testing and development, such as the Support API"),(0,i.yg)("li",{parentName:"ul"},"Populate with ",(0,i.yg)("inlineCode",{parentName:"li"},"https")," for production environments where sensitive information may transmit over TLS. Note that the server and routing configs will handle the TLS path routing and security.")))),(0,i.yg)("h2",{id:"creating-a-new-api-html"},"Creating a new API html"),(0,i.yg)("p",null,"We will also need an HTML file for the Swagger-UI. To do this as easy as possible, navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"mymove/public/swagger-ui"),", where you will find existing HTML files for the APIs such as ",(0,i.yg)("inlineCode",{parentName:"p"},"prime.html")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"support.html"),".\nSince these HTML files only differ by one line, we will simply duplicate one and modify said line. Create a new copy of an existing HTML API file, such as ",(0,i.yg)("inlineCode",{parentName:"p"},"prime.html"),". Give this new file a name of ",(0,i.yg)("inlineCode",{parentName:"p"},"${API_NAME}.html"),", and then near line 100, where the url attribute is passed into the ",(0,i.yg)("inlineCode",{parentName:"p"},"SwaggerUIBundle")," function, adjust the existing API name to be your new one. For example, replacing ",(0,i.yg)("inlineCode",{parentName:"p"},'url: "/prime/v1/swagger.yaml"')," with ",(0,i.yg)("inlineCode",{parentName:"p"},'url: "/apiNameHere/v1/swagger.yaml"'),". Leave this file for now\nas we will come back later when mounting the API handler for Swagger UI."),(0,i.yg)("h2",{id:"generating-swagger-code-for-your-api"},"Generating swagger code for your API"),(0,i.yg)("p",null,"Once your Swagger API ",(0,i.yg)("inlineCode",{parentName:"p"},".yaml")," files have been created under ",(0,i.yg)("inlineCode",{parentName:"p"},"swagger-def"),", we need to make sure they can be generated for use by our backend. To do this, we need to modify the ",(0,i.yg)("inlineCode",{parentName:"p"},"gen-server")," script found under ",(0,i.yg)("inlineCode",{parentName:"p"},"mymove/scripts/gen-server"),"."),(0,i.yg)("p",null,"Within this file you will see two sections at the bottom to execute the bash script functions ",(0,i.yg)("inlineCode",{parentName:"p"},"generate_server")," and ",(0,i.yg)("inlineCode",{parentName:"p"},"generate_client"),". Please add a new execution line under these two sections for your new API."),(0,i.yg)("p",null,"Example:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"# Generate Server Code\n...\ngenerate_server swagger/${API_FILENAME}.yaml    ${API_NAME}messages    ${API_NAME}api    ${API_NAME}operations\n\n# Generate Client Code\n...\ngenerate_client swagger/${API_FILENAME}.yaml ${API_NAME}messages ${API_NAME}client\n\n")),(0,i.yg)("p",null,"Once you have added the new execution lines to the bash script, when the ",(0,i.yg)("inlineCode",{parentName:"p"},"gen-server")," script executes, it will generate the new swagger server and client code for your API. Feel free to execute this script manually yourself or run ",(0,i.yg)("inlineCode",{parentName:"p"},"make server_run")," within the MyMove repository."),(0,i.yg)("h2",{id:"creating-your-api-handler"},"Creating your API handler"),(0,i.yg)("p",null,"Now that we have a basic swagger definition for our API and the corresponding Swagger code generated, we are now able to create the API handler and mount it."),(0,i.yg)("p",null,"Navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"mymove/pkg/handlers")," and create a new folder called ",(0,i.yg)("inlineCode",{parentName:"p"},"${API_NAME}api"),", similar to ",(0,i.yg)("inlineCode",{parentName:"p"},"primeapi"),", ",(0,i.yg)("inlineCode",{parentName:"p"},"ghcapi"),", etc. Within this folder create a new file called ",(0,i.yg)("inlineCode",{parentName:"p"},"api.go"),". Template your file like so:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'package ${API_NAME}api\n\nimport (\n    "log"\n\n    "github.com/go-openapi/loads"\n\n    "github.com/transcom/mymove/pkg/gen/${API_NAME}api"\n    ${API_NAME}ops "github.com/transcom/mymove/pkg/gen/${API_NAME}api/${API_NAME}operations"\n    "github.com/transcom/mymove/pkg/handlers"\n)\n\nfunc New${API_NAME}API(handlerConfig handlers.HandlerConfig) *${API_NAME}ops.MymoveAPI {\n    ${API_NAME}Spec, err := loads.Analyzed(${API_NAME}api.SwaggerJSON, "")\n    if err != nil {\n        log.Fatalln(err)\n    }\n    ${API_NAME}API := ${API_NAME}ops.NewMymoveAPI(${API_NAME}Spec)\n    ${API_NAME}API.ServeError = handlers.ServeCustomError\n\n    return ${API_NAME}API\n}\n')),(0,i.yg)("p",null,'This file will receive some test coverage after we add the API to the "routing" portion of our backend. Now that there is a dedicated handler func to instantiate your new API, we need to decide which server it will be attached to. '),(0,i.yg)("h2",{id:"milmove-servers"},"MilMove servers"),(0,i.yg)("p",null,"There are four MilMove servers"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"health"),(0,i.yg)("li",{parentName:"ul"},"no-tls"),(0,i.yg)("li",{parentName:"ul"},"tls"),(0,i.yg)("li",{parentName:"ul"},"mutual-tls")),(0,i.yg)("p",null,"These services are launches inside the ",(0,i.yg)("inlineCode",{parentName:"p"},"serveFunction")," within ",(0,i.yg)("inlineCode",{parentName:"p"},"mymove/cmd/milmove/serve.go"),"."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Health"),"\nThe health server is a dedicated server only for health checks and the health API."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"no-tls"),"\nThe no-tls server is typically only utilized during development, this facilitates our client and office API calls."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"tls"),"\nThe tls server is the production server for MilMove client and office API calls"),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"mutual-tls"),"\nThe mutual tls server is our production server for our public API. This is where the Prime and PPTAS APIs are hosted. This server also runs\nduring the development environment, but is typically proxied to from the frontend on port 3000 under ",(0,i.yg)("inlineCode",{parentName:"p"},"primelocal:3000"),". If you create your API\non the mutual-tls server (Prime router is the generic name), then you will not be able to access it under ",(0,i.yg)("inlineCode",{parentName:"p"},"primelocal:3000")," unless you add it to the proxy at ",(0,i.yg)("inlineCode",{parentName:"p"},"mymove/src/setupProxy.js"),". More details further along."),(0,i.yg)("p",null,(0,i.yg)("strong",{parentName:"p"},"Which to choose"),"\nYou are going to append your new API path to one of these servers. Most likely if you are reading this then it is not an endpoint specific to the Office, Customer, or Admin APIs, and rather a new API entirely for\nanother Department of Defense (DOD) agency. If you are looking to create a new API as an expansion upon internal MyMove operations, then please resort to no-tls or tls. If you are\nopening access and creating a new API for a third-party agency, then you will want to use the mutual-tls server for extra security."),(0,i.yg)("h2",{id:"mounting-your-api-to-an-existing-server"},"Mounting your API to an existing server"),(0,i.yg)("p",null,"At the time of this writing, all of the servers share the same routing config, where a HostRouter then routes incoming requests to the corresponding sub-router, appending additional layers of middleware security accordingly. Please\nattempt to pull up the ",(0,i.yg)("inlineCode",{parentName:"p"},"InitRouting")," func within ",(0,i.yg)("inlineCode",{parentName:"p"},"mymove/pkg/handlers/routing/routing_init.go"),". Within this file you will find the heart of our routing configuration. Within this func you will find the routers being created within the server.\nAll servers call this func and depending on the domain name, will be routed to the correct router accordingly. "),(0,i.yg)("p",null,"Currently, the five routers are as follows"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},"Mil Router",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"no-tls"),(0,i.yg)("li",{parentName:"ul"},"tls server"))),(0,i.yg)("li",{parentName:"ul"},"Office Router",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"no-tls server"),(0,i.yg)("li",{parentName:"ul"},"tls server"))),(0,i.yg)("li",{parentName:"ul"},"Admin Router",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"mutual-tls server"),(0,i.yg)("li",{parentName:"ul"},"proxied during development"))),(0,i.yg)("li",{parentName:"ul"},"Prime Router",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"mutual-tls server"),(0,i.yg)("li",{parentName:"ul"},'proxied under "Prime Simulator" during development'))),(0,i.yg)("li",{parentName:"ul"},"Health Router",(0,i.yg)("ul",{parentName:"li"},(0,i.yg)("li",{parentName:"ul"},"health server")))),(0,i.yg)("p",null,"The proxy will be covered further along. Please navigate to the function that creates the desired router you want to host your API on. Creating a new router should only ever be done if you are standing up a new server."),(0,i.yg)("p",null,"This example will utilize the Prime router. The Prime router is stood up under the ",(0,i.yg)("inlineCode",{parentName:"p"},"newPrimeRouter")," func, and currently looks like this:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'// This "Prime" router is really just the "API" router for MilMove.\n// It was initially just named under "Prime" as it was the only use of the router\nfunc newPrimeRouter(appCtx appcontext.AppContext, redisPool *redis.Pool,\n    routingConfig *Config, telemetryConfig *telemetry.Config, serverName string) chi.Router {\n\n    site := newBaseRouter(appCtx, routingConfig, telemetryConfig, serverName)\n\n    mountHealthRoute(appCtx, redisPool, routingConfig, site)\n    mountPrimeAPI(appCtx, routingConfig, site)\n    mountSupportAPI(appCtx, routingConfig, site)\n    mountTestharnessAPI(appCtx, routingConfig, site)\n    mountPPTASAPI(appCtx, routingConfig, site)\n    return site\n}\n')),(0,i.yg)("p",null,"This func, ",(0,i.yg)("inlineCode",{parentName:"p"},"newPrimeRouter"),", creates a ",(0,i.yg)("a",{parentName:"p",href:"https://github.com/go-chi/chi"},"chi router")," with shared middleware with the ",(0,i.yg)("inlineCode",{parentName:"p"},"newBaseRouter")," call. This means that with the chi router being created with shared middleware,\nwe are now able to mount paths (APIs) to the Prime router, inheriting basic middleware and then when mounting additional paths, additional middleware can be added if desired."),(0,i.yg)("p",null,"We are going to want to create a new function called ",(0,i.yg)("inlineCode",{parentName:"p"},"mount${API_NAME}"),", based on the following template:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'// Please note that this is a template that will need additional customization and security per requirements.\n// For example, this mounting does not conditionally serve from within the routing config. That is a\n// customization you will want to introduce.\nfunc mount${API_NAME}API(appCtx appcontext.AppContext, routingConfig *Config, site chi.Router) {\n        site.Route("/${API_NAME}/v1", func(r chi.Router) {\n            r.Method(\n                "GET",\n                "/swagger.yaml", // Here is the endpoint we are going to hit to make sure our API is mounted and reachable\n                handlers.NewFileHandler(routingConfig.FileSystem,\n                    routingConfig.${API_NAME}SwaggerPath))\n            if routingConfig.ServeSwaggerUI { // Conditionally loading the SwaggerUI just like the other APIs\n                r.Method("GET", "/docs",\n                    handlers.NewFileHandler(routingConfig.FileSystem,\n                        path.Join(routingConfig.BuildRoot, "swagger-ui", "${API_NAME}.html"))) // Here\'s that HTML file we made earlier\n            } else {\n                r.Method("GET", "/docs", http.NotFoundHandler())\n            }\n            api := ${API_NAME}api.New${API_NAME}API(routingConfig.HandlerConfig)\n            tracingMiddleware := middleware.OpenAPITracing(api)\n            r.Mount("/", api.Serve(tracingMiddleware))\n        })\n}\n')),(0,i.yg)("p",null,"Now, add this mounting func to the router you want to branch off, in our example we used the Prime router."),(0,i.yg)("p",null,"Example"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},"  ...\n    mountSupportAPI(appCtx, routingConfig, site)\n    mountTestharnessAPI(appCtx, routingConfig, site)\n    mountPPTASAPI(appCtx, routingConfig, site)\n  mount${API_NAME}(appCtx, routingConfig, site) // Order does not matter\n    return site\n  ...\n")),(0,i.yg)("h2",{id:"creating-a-proxy-for-your-api"},"Creating a proxy for your API"),(0,i.yg)("admonition",{type:"tip"},(0,i.yg)("p",{parentName:"admonition"},"Just because you don't proxy your API doesn't mean you can't reach it. Typically, this is only really even necessary for mutual-tls APIs, but it is not required.\nFor example, if you are hosting on the Prime then it will be immediately mounted and hosted on the real mutual-tls server (locally) at domain ",(0,i.yg)("inlineCode",{parentName:"p"},"primelocal"),", port ",(0,i.yg)("inlineCode",{parentName:"p"},"9443"),".\nOur documentation leads most to utilize ",(0,i.yg)("inlineCode",{parentName:"p"},"primelocal:3000"),", this is a proxy URL. This proxy URL is only accessible while the frontend is running.")),(0,i.yg)("p",null,"We utilize a frontend proxy for our API that can be utilized during testing to make it easy to access the HTTPS api via an HTTP channel. Simply navigate to ",(0,i.yg)("inlineCode",{parentName:"p"},"mymove/src/setupProxy.js"),"\nand create a new line, adding a new proxy middleware to handle routes to ",(0,i.yg)("inlineCode",{parentName:"p"},"/${API_NAME}")," with the target of ",(0,i.yg)("inlineCode",{parentName:"p"},"milmovelocal"),"."),(0,i.yg)("h2",{id:"creating-your-api-test"},"Creating your API test"),(0,i.yg)("p",null,"We are going to want to create a swagger.yaml GET request test for the new API. Routing tests can be found under ",(0,i.yg)("inlineCode",{parentName:"p"},"mymove/pkg/handlers/routing"),". Create a new folder called ",(0,i.yg)("inlineCode",{parentName:"p"},"${API_NAME}_test"),".\nWithin this folder, we want to create a new test suite for routing tests and your API. Create a file called ",(0,i.yg)("inlineCode",{parentName:"p"},"${API_NAME}_test.go"),"."),(0,i.yg)("p",null,"Populate ",(0,i.yg)("inlineCode",{parentName:"p"},"${API_NAME}_test.go")," like so:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'package ${API_NAME}api_test\n\nimport (\n    "testing"\n\n    "github.com/stretchr/testify/suite"\n\n    "github.com/transcom/mymove/pkg/handlers/routing"\n)\n\ntype ${API_NAME}APISuite struct {\n    routing.BaseRoutingSuite\n}\n\nfunc Test${API_NAME}Suite(t *testing.T) {\n    hs := &${API_NAME}APISuite{\n        routing.NewBaseRoutingSuite(),\n    }\n    suite.Run(t, hs)\n    hs.PopTestSuite.TearDown()\n}\n')),(0,i.yg)("p",null,"This creates our test suite so we can write a test for the ",(0,i.yg)("inlineCode",{parentName:"p"},".yaml")," file. To make a test for your ",(0,i.yg)("inlineCode",{parentName:"p"},"swagger.yaml")," GET request, create a file called ",(0,i.yg)("inlineCode",{parentName:"p"},"swagger_test.go"),"."),(0,i.yg)("p",null,"Populate ",(0,i.yg)("inlineCode",{parentName:"p"},"swagger_test.go")," like so:"),(0,i.yg)("pre",null,(0,i.yg)("code",{parentName:"pre"},'package ${API_NAME}api_test\n\nimport (\n    "io"\n    "net/http"\n    "net/http/httptest"\n\n    "github.com/transcom/mymove/pkg/factory"\n)\n\nfunc (suite *${API_NAME}APISuite) TestSwaggerYaml() {\n    routingConfig := suite.RoutingConfig()\n    routingConfig.${API_NAME}SwaggerPath = "foo/bar/baz"\n    swaggerContent := "some\\nswagger\\ncontent\\n"\n    suite.CreateFileWithContent(routingConfig.${API_NAME}SwaggerPath, swaggerContent)\n    siteHandler := suite.SetupCustomSiteHandler(routingConfig)\n\n  // Adjust the request requirements per server or API needs\n    cert := factory.BuildPrimeClientCert(suite.DB())\n    req := suite.NewAuthenticatedPrimeRequest("GET", "/${API_NAME}/v1/swagger.yaml", nil, cert)\n    rr := httptest.NewRecorder()\n    siteHandler.ServeHTTP(rr, req)\n    suite.Equal(http.StatusOK, rr.Code)\n    actualData, err := io.ReadAll(rr.Body)\n    suite.NoError(err)\n    suite.Equal(swaggerContent, string(actualData))\n}\n')),(0,i.yg)("p",null,"The ",(0,i.yg)("inlineCode",{parentName:"p"},"swagger_test.go")," file should provide a test that should pass and successfully access your ",(0,i.yg)("inlineCode",{parentName:"p"},"swagger.yaml")," file."),(0,i.yg)("h2",{id:"manually-testing-your-api"},"Manually testing your API"),(0,i.yg)("p",null,"Please only conduct manual testing after your testing suite has been confirmed to pass. It is better practice to troubleshoot and test within the files themselves rather than manually testing and modifying code."),(0,i.yg)("p",null,"Ensure all files are saved, and then turn on both your client and server. It is important to have both in case you are going to use a proxy endpoint such as ",(0,i.yg)("inlineCode",{parentName:"p"},"primelocal:3000"),". Now,\nas we didn't introduce any additional middleware security, we only need to satisfy the base router's middleware. Typically this would include creating an office session if\nbranched off the GHC/Office or Admin API, or having your certs already setup for something such as the mutual-tls Prime server.  If you do not know how to do this, please see\nthe ",(0,i.yg)("a",{parentName:"p",href:"/mymove-docs/docs/tools/postman/setting-up-postman"},"Setting up Postman")," article."),(0,i.yg)("p",null,"With your client and server running, please utilize an API tool such as Postman to test a GET request to the ",(0,i.yg)("inlineCode",{parentName:"p"},".yaml")," file that was explicitly mounted inside the mount${API_NAME} function. If\nall went well, you should successfully be able to use a GET request to hit the path of your API, meaning you have created and mounted your API within MilMove. As our API architecture\nis subject to change, please reach out to the MilMove developers for any additional assistance or troubleshooting during this process."),(0,i.yg)("h2",{id:"related"},"Related:"),(0,i.yg)("ul",null,(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"/docs/backend/testing/acceptance-testing-payment-requests"},"Acceptance testing payment requests")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"/docs/frontend/guides/access-swagger-endpoints-from-react"},"How To Call Swagger Endpoints from React")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"/docs/api/testing/acceptance-testing-prime-api-endpoints"},"Acceptance Testing Prime API")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"/docs/api/guides/how-to-deprecate-endpoints"},"How to Deprecate an API Endpoint")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"/docs/api/testing/how-to-test-the-prime-api"},"How to Test the Prime API")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"/docs/api/guides/guide-to-creating-an-endpoint"},"Creating an Endpoint")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"/docs/api/guides/guide-to-creating-an-api"},"Creating an API")),(0,i.yg)("li",{parentName:"ul"},(0,i.yg)("a",{parentName:"li",href:"https://goswagger.io/tutorial/todo-list.html"},"Swagger tutorial"))))}d.isMDXComponent=!0}}]);