"use strict";(self.webpackChunkmymove_docs=self.webpackChunkmymove_docs||[]).push([[9e3],{9213:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>h});var o=a(87462),n=(a(67294),a(3905));a(8209);const i={},s="How to Track New Events in Move History",r={unversionedId:"frontend/guides/how-to-add-move-history-events",id:"frontend/guides/how-to-add-move-history-events",title:"How to Track New Events in Move History",description:"Overview",source:"@site/docs/frontend/guides/how-to-add-move-history-events.md",sourceDirName:"frontend/guides",slug:"/frontend/guides/how-to-add-move-history-events",permalink:"/mymove-docs/docs/frontend/guides/how-to-add-move-history-events",draft:!1,editUrl:"https://github.com/transcom/mymove-docs/edit/main/docs/frontend/guides/how-to-add-move-history-events.md",tags:[],version:"current",frontMatter:{},sidebar:"frontendSidebar",previous:{title:"How we use react-router",permalink:"/mymove-docs/docs/frontend/guides/how-we-use-react-router"},next:{title:"Using Modals",permalink:"/mymove-docs/docs/frontend/guides/using-modals"}},l={},h=[{value:"Overview",id:"overview",level:2},{value:"Detailed Workflow",id:"detailed-workflow",level:2},{value:"1. Ensure the action is currently being tracked in our audit_history table",id:"1-ensure-the-action-is-currently-being-tracked-in-our-audit_history-table",level:3},{value:"files: create a migration",id:"files-create-a-migration",level:4},{value:"2. Check if the action is currently being tracked by our query",id:"2-check-if-the-action-is-currently-being-tracked-by-our-query",level:3},{value:"files: move_history_fetcher.sql",id:"files-move_history_fetchersql",level:4},{value:"3. Create a new event template in the EventTemplates directory, following the design pattern you see in other eventTemplates",id:"3-create-a-new-event-template-in-the-eventtemplates-directory-following-the-design-pattern-you-see-in-other-eventtemplates",level:3},{value:"files: Tables.js, Operations.js, FieldMappings.js",id:"files-tablesjs-operationsjs-fieldmappingsjs",level:4}],d={toc:h},m="wrapper";function c(e){let{components:t,...a}=e;return(0,n.kt)(m,(0,o.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"how-to-track-new-events-in-move-history"},"How to Track New Events in Move History"),(0,n.kt)("h2",{id:"overview"},"Overview"),(0,n.kt)("p",null,"Our Move history component is a useful tool for our office users; when a move is created, changed, or edited, our move history component displays the who, what, and when of those changes. We achieve this through the use of database triggers monitoring certain tables; whenever data in those tables is inserted, deleted, or updated, a record is inserted into our audit_history table to capture that event. This record contains information relevant to the transaction: when it happened, who did it, what table was changed, what was the old data, what is the new data, etc. Because the audit_history table holds the history of all moves, to pull the associated records for a move we use move_history_fetcher.sql to pull only the records that are associated with the currently viewed move."),(0,n.kt)("p",null,"In the front end, our MoveHistory component passes the move locator (such as 'AB6PPM') to getMoveHistory, receives the relevant data back, and passes that to our TemplateManager. The TemplateManager looks at each row, specifically the action (UPDATE, DELETE, or INSERT), eventName (the operationId), and the tableName, and determines which template to use to display that data (templates are housed in the ",(0,n.kt)("a",{parentName:"p",href:"https://github.com/transcom/mymove/tree/main/src/constants/MoveHistory/EventTemplates"},"EventTemplates")," directory). The template then takes the data and formats it for each particular combination of action, event, and table."),(0,n.kt)("p",null,"At its most basic level, here are the changes needed to track a new event in our Move history component:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Ensure the action is currently being tracked in our audit_history table (and add a trigger if not)"),(0,n.kt)("li",{parentName:"ol"},"Check if the action is currently being tracked by our query (and add it if not)"),(0,n.kt)("li",{parentName:"ol"},"Create a new event template for it in the EventTemplates directory")),(0,n.kt)("h2",{id:"detailed-workflow"},"Detailed Workflow"),(0,n.kt)("h3",{id:"1-ensure-the-action-is-currently-being-tracked-in-our-audit_history-table"},"1. Ensure the action is currently being tracked in our audit_history table"),(0,n.kt)("h4",{id:"files-create-a-migration"},"files: create a migration"),(0,n.kt)("p",null,"To accomplish this, trigger the action in the UI, then use the command line or dbeaver to view the audit_history table, sorted by timestamp."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT * FROM audit_history ORDER BY action_tstamp_tx DESC LIMIT 20\n")),(0,n.kt)("p",null,"If the action triggered an entry, you can probably move to the next step. If not, you'll need to create a database trigger in a migration (",(0,n.kt)("a",{parentName:"p",href:"https://transcom.github.io/mymove-docs/docs/backend/setup/database-migrations/#creating-migrations"},"documentation for creating a migration"),"):"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"milmove gen migration -n <migration_name>\n")),(0,n.kt)("p",null,"The migration itself should look something like this:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT add_audit_history_table(target_table := 'table_name', audit_rows := BOOLEAN 't', audit_query_text := BOOLEAN 't', ignored_cols := ARRAY['created_at', 'updated_at']);\n")),(0,n.kt)("p",null,"Once you've created the migration for a database trigger, run make db_dev_fresh to migrate the changes and reset your db. Use the UI to trigger the action again, check the audit_history table and confirm that a record now exists for the transaction."),(0,n.kt)("h3",{id:"2-check-if-the-action-is-currently-being-tracked-by-our-query"},"2. Check if the action is currently being tracked by our query"),(0,n.kt)("h4",{id:"files-move_history_fetchersql"},"files: ",(0,n.kt)("a",{parentName:"h4",href:"https://github.com/transcom/mymove/blob/main/pkg/assets/sql_scripts/move_history_fetcher.sql"},"move_history_fetcher.sql")),(0,n.kt)("p",null,"The easiest way to do this is to open a new SQL script in dbeaver, copy the existing move_history_fetcher.sql file over from vscode, and hardcode the locator in single quotes."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"WITH move AS (\n    SELECT\n        moves.*\n    FROM\n        moves\n    WHERE\n        moves.locator = 'AB6PPM'\n),\n...\n")),(0,n.kt)("p",null,"If you execute this, and see an entry for your action (they're ordered so the most recent actions will be at the top), you can move on to the next step. Otherwise, you will need to add some sql to this file. There is a chance you can simply build on existing temp tables in this query. For example, if the action you're trying to track is address related, it may fit into the existing move_addresses portion of the query. If not, you will have to create a new temp table in this query."),(0,n.kt)("p",null,"The design pattern for that is as follows:"),(0,n.kt)("ol",null,(0,n.kt)("li",{parentName:"ol"},"Create a new temp table, using audit_history.object_id to join the existing temp tables to have access to the data you need")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"ppms (ppm_id, shipment_type, shipment_id) AS (\n    SELECT\n        audit_history.object_id,\n        move_shipments.shipment_type,\n        move_shipments.id\n    FROM\n        audit_history\n    JOIN ppm_shipments ON audit_history.object_id = ppm_shipments.id\n    JOIN move_shipments ON move_shipments.id = ppm_shipments.shipment_id\n),\n")),(0,n.kt)("ol",{start:2},(0,n.kt)("li",{parentName:"ol"},"Create another temp table (by convention, the name should end with ",(0,n.kt)("inlineCode",{parentName:"li"},"_logs"),") to return audit_history rows and context (JSON with whatever extra data you may need thats not included in the audit_history entry)")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"ppm_logs AS (\n    SELECT\n        audit_history.*,\n            jsonb_agg(\n                jsonb_strip_nulls(\n                    jsonb_build_object(\n                        'shipment_type', ppms.shipment_type,\n                        'shipment_id_abbr', (CASE WHEN ppms.shipment_id IS NOT NULL THEN LEFT(ppms.shipment_id::TEXT, 5) ELSE NULL END)\n                    )\n                )\n            )::TEXT AS context,\n        COALESCE(ppms.shipment_id::TEXT, NULL)::TEXT AS context_id\n    FROM\n        audit_history\n    JOIN ppms ON ppms.ppm_id = audit_history.object_id\n    WHERE audit_history.table_name = 'ppm_shipments'\n    GROUP BY\n        ppms.shipment_id, audit_history.id\n),\n")),(0,n.kt)("ol",{start:3},(0,n.kt)("li",{parentName:"ol"},"Add the ",(0,n.kt)("inlineCode",{parentName:"li"},"_logs")," temp table to the union chain towards the end of the query")),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-sql"},"combined_logs AS (\n    SELECT\n        *\n    FROM\n        address_logs\n    UNION\n    SELECT\n        *\n    FROM\n        sit_logs\n    UNION\n    SELECT\n        *\n    FROM\n        ppm_logs\n...\n\n")),(0,n.kt)("p",null,"Execute your script in dbeaver to test your script. If it is working, copy the script back over to vscode and replace your hardcoded locator string on line 7 with the original variable."),(0,n.kt)("h3",{id:"3-create-a-new-event-template-in-the-eventtemplates-directory-following-the-design-pattern-you-see-in-other-eventtemplates"},"3. Create a new event template in the EventTemplates directory, following the design pattern you see in other eventTemplates"),(0,n.kt)("h4",{id:"files-tablesjs-operationsjs-fieldmappingsjs"},"files: ",(0,n.kt)("a",{parentName:"h4",href:"https://github.com/transcom/mymove/blob/main/src/constants/MoveHistory/Database/Tables.js"},"Tables.js"),", ",(0,n.kt)("a",{parentName:"h4",href:"https://github.com/transcom/mymove/blob/main/src/constants/MoveHistory/UIDisplay/Operations.js"},"Operations.js"),", ",(0,n.kt)("a",{parentName:"h4",href:"https://github.com/transcom/mymove/blob/main/src/constants/MoveHistory/Database/FieldMappings.js"},"FieldMappings.js")),(0,n.kt)("p",null,"At this point, we know the backend is recording the transaction in question, and our getMoveHistory query is retrieving it. If we go to our Move history on the move, we should see entries for our new history records, with empty details. These are some of the default event templates, which are displayed if there is not a template specific to our combination of action/eventName/tableName. At this point, stub out a new event template (you pick the filename and where it is housed) with something like this:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-javascript"},"import React from 'react';\n\nimport a from 'constants/MoveHistory/Database/Actions';\nimport o from 'constants/MoveHistory/UIDisplay/Operations';\nimport t from 'constants/MoveHistory/Database/Tables';\nimport LabeledDetails from 'pages/Office/MoveHistory/LabeledDetails';\nimport { getMtoShipmentLabel } from 'utils/formatMtoShipment';\n\nconst formatChangedValues = (historyRecord) => {\n    const { changedValues } = historyRecord;\n    const newChangedValues = {\n        ...changedValues,\n        ...getMtoShipmentLabel(historyRecord),\n    };\n\n    return { ...historyRecord, changedValues: newChangedValues };\n};\n\nexport default {\n    action: a.INSERT, // action column in audit_history\n    eventName: o.createMTOShipment, // event_name column in audit_history\n    tableName: t.mto_shipments, // table_name column in audit_history\n    getEventNameDisplay: () => 'Created shipment', // what you want the Event column to read on the UI\n    getDetails: (historyRecord) => <LabeledDetails historyRecord={formatChangedValues(historyRecord)} />, // LabeledDetails will handle most formatting\n};\n\n")),(0,n.kt)("p",null,"Again the key points here are action, eventName, and tableName -- make sure they all align with the row. The formatChangedValues function and LabeledDetails component should do most of the heavy lifting, formatting the changedValues key-value pairs into something that can display on the MoveHistory. You may have to update some of the front end constant files:"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/transcom/mymove/blob/main/src/constants/MoveHistory/Database/Tables.js"},"Tables.js")," for table_name"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/transcom/mymove/blob/main/src/constants/MoveHistory/UIDisplay/Operations.js"},"Operations.js")," for event_name"),(0,n.kt)("p",null,(0,n.kt)("a",{parentName:"p",href:"https://github.com/transcom/mymove/blob/main/src/constants/MoveHistory/Database/FieldMappings.js"},"FieldMappings.js")," for values in changed_values that don't yet appear in the UI"),(0,n.kt)("p",null,"Reach out on slack if you have any questions."),(0,n.kt)("p",null,"For reference:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/transcom/mymove/pull/11628"},"PR 11628")," follows a semi happy path of implementation"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://github.com/transcom/mymove/pull/11585"},"PR 11585")," has to jump through some hoops to provide requested data via context")))}c.isMDXComponent=!0}}]);