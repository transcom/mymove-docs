"use strict";(self.webpackChunkmymove_docs=self.webpackChunkmymove_docs||[]).push([[648],{76850:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>r,toc:()=>p});var s=a(87462),n=(a(67294),a(3905));a(8209);const i={title:"0010 Isolate Test Access to Database"},o="Isolate Test Access to Database",r={unversionedId:"adrs/isolate-test-access-to-database",id:"adrs/isolate-test-access-to-database",title:"0010 Isolate Test Access to Database",description:"NOTE: This ADR has been superseded by ADR0062 Run Tests in Transactions.",source:"@site/docs/adrs/0010-isolate-test-access-to-database.md",sourceDirName:"adrs",slug:"/adrs/isolate-test-access-to-database",permalink:"/mymove-docs/docs/adrs/isolate-test-access-to-database",draft:!1,editUrl:"https://github.com/transcom/mymove-docs/edit/main/docs/adrs/0010-isolate-test-access-to-database.md",tags:[],version:"current",sidebarPosition:10,frontMatter:{title:"0010 Isolate Test Access to Database"},sidebar:"adrsSidebar",previous:{title:"0009 Generate forms from swagger definitions of payload",permalink:"/mymove-docs/docs/adrs/form-creation-from-swagger"},next:{title:"0011 Test Suites",permalink:"/mymove-docs/docs/adrs/test-suites"}},l={},p=[{value:"Considered Alternatives",id:"considered-alternatives",level:2},{value:"Decision Outcome",id:"decision-outcome",level:2},{value:"Pros and Cons of the Alternatives",id:"pros-and-cons-of-the-alternatives",level:2},{value:"Wrap test execution in a database transaction",id:"wrap-test-execution-in-a-database-transaction",level:3}],c={toc:p},d="wrapper";function u(e){let{components:t,...a}=e;return(0,n.kt)(d,(0,s.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"isolate-test-access-to-database"},"Isolate Test Access to Database"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"NOTE:")," This ADR has been superseded by ",(0,n.kt)("a",{parentName:"p",href:"/mymove-docs/docs/adrs/run-tests-in-transactions"},"ADR0062 Run Tests in Transactions"),"."),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"User Story:")," ",(0,n.kt)("a",{parentName:"p",href:"https://www.pivotaltracker.com/story/show/155076695"},"155076695")),(0,n.kt)("p",null,"Our tests currently execute against a single database and do not clean up after themselves. As each tests runs, any mutations made to the database persist. This lack of isolation between tests can lead to test reliability issues."),(0,n.kt)("p",null,"Our priorities are, in order:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Reliable tests (tests that only sometimes pass don't provide value)."),(0,n.kt)("li",{parentName:"ul"},"Developer experience (we don't want to add a lot of boilerplate to each test that obscures its true intent.)"),(0,n.kt)("li",{parentName:"ul"},"Minimizing test run duration (we don't want to optimize for speed this early in the project.)")),(0,n.kt)("h2",{id:"considered-alternatives"},"Considered Alternatives"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Wrap test execution in a database transaction")," Execute tests that leverage the database within SQL transactions, calling ROLLBACK() at the end of each test to prevent any mutations from persisting after the test completes.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Truncate tables between tests")," Delete all rows from the database using ",(0,n.kt)("inlineCode",{parentName:"p"},"TRUNCATE")," after each test executes and ensure that only a single test is communicating with the test database at one time."))),(0,n.kt)("h2",{id:"decision-outcome"},"Decision Outcome"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Chosen Alternative: ",(0,n.kt)("strong",{parentName:"p"},"Truncate tables between tests"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"The main driver behind this decision was simplicity. We anticipate using transactions within our application (although we aren't already), and wrapping tests in transactions would complicate matters as transactions can't be simply nested. It is possible to emulate nested transactions using ",(0,n.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/8.1/static/sql-savepoint.html"},(0,n.kt)("inlineCode",{parentName:"a"},"SAVEPOINT")),", but this is not supported by Pop or sqlx and pursuing this route would require us to write and maintain additional non-trivial code in the project.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("inlineCode",{parentName:"p"},"go test")," executes tests from a single package serially unless there are tests that are explicitly marked as able to run in parallel using ",(0,n.kt)("a",{parentName:"p",href:"https://golang.org/pkg/testing/#T.Parallel"},(0,n.kt)("inlineCode",{parentName:"a"},"t.Parallel()")),". We do, however, have multiple packages with tests that use the database (currently ",(0,n.kt)("inlineCode",{parentName:"p"},"models")," and ",(0,n.kt)("inlineCode",{parentName:"p"},"handlers"),"), so we will additionally need to pass ",(0,n.kt)("inlineCode",{parentName:"p"},"-test.parallel 1")," to ",(0,n.kt)("inlineCode",{parentName:"p"},"go test")," so that packages as well as individual tests are executed serially. Otherwise, multiple tests using the database will encounter collisions."),(0,n.kt)("p",{parentName:"li"},"Executing each package's tests serially will increase the time required for a project-wide test run, but at this time this is a reasonable trade-off as the suite duration time is currently acceptable. If speed of tests execution become a concern in the future, there are a few approaches we could pursue without too much effort, including having a test database per package with tests hitting the database.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"This strategy requires the ability to run code before or after each test, which will be addressed in a future ADR.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://github.com/gobuffalo/pop/blob/9f77e19c929eda4c13f525296fe751a90de86619/postgresql.go#L232-L248"},"Pop uses ",(0,n.kt)("inlineCode",{parentName:"a"},"TRUNCATE"))," to implement ",(0,n.kt)("a",{parentName:"p",href:"https://godoc.org/github.com/gobuffalo/pop#Connection.TruncateAll"},(0,n.kt)("inlineCode",{parentName:"a"},"TruncateAll()")),"."))),(0,n.kt)("h2",{id:"pros-and-cons-of-the-alternatives"},"Pros and Cons of the Alternatives"),(0,n.kt)("h3",{id:"wrap-test-execution-in-a-database-transaction"},"Wrap test execution in a database transaction"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"+")," Allows multiple tests to interact with the database at once without interfering with each other."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-")," Complicates testing code that itself uses transactions (see discussion re: transaction nesting above)."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-")," Requires writing additional testing helpers to manage transactions."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-")," Requires that all tests use the correct ",(0,n.kt)("inlineCode",{parentName:"li"},"*pop.Connection")," that has an open transaction, which is difficult to verify without manual code inspection."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"+")," Is considered to be faster than truncation (we did not perform benchmarking as speed was not a top priority).")))}u.isMDXComponent=!0}}]);