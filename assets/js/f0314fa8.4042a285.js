"use strict";(self.webpackChunkmymove_docs=self.webpackChunkmymove_docs||[]).push([[9583],{59592:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>l});var r=n(87462),a=(n(67294),n(3905));n(8209);const i={sidebar_position:6},o="Implementation",s={unversionedId:"backend/guides/service-objects/implementation",id:"backend/guides/service-objects/implementation",title:"Implementation",description:"Now we can start implementing our service objects. We'll start with the creator service object and then work on the",source:"@site/docs/backend/guides/service-objects/implementation.md",sourceDirName:"backend/guides/service-objects",slug:"/backend/guides/service-objects/implementation",permalink:"/mymove-docs/docs/backend/guides/service-objects/implementation",draft:!1,editUrl:"https://github.com/transcom/mymove-docs/edit/main/docs/backend/guides/service-objects/implementation.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"backendSidebar",previous:{title:"Validation",permalink:"/mymove-docs/docs/backend/guides/service-objects/validation"},next:{title:"Usage",permalink:"/mymove-docs/docs/backend/guides/service-objects/usage"}},p={},l=[{value:"<code>Pet</code> Creator",id:"pet-creator",level:2},{value:"Creating the Struct",id:"creating-the-struct",level:3},{value:"Creating the Action Function",id:"creating-the-action-function",level:3},{value:"Creating An Instance of Our Service Object",id:"creating-an-instance-of-our-service-object",level:3},{value:"Implementing the Creator",id:"implementing-the-creator",level:3},{value:"Tests for the Creator",id:"tests-for-the-creator",level:4},{value:"Validating Creator Input",id:"validating-creator-input",level:4},{value:"Creating the Pet",id:"creating-the-pet",level:4},{value:"Final <code>pet_creator.go</code>",id:"final-pet_creatorgo",level:4},{value:"Implementing the Updater",id:"implementing-the-updater",level:3},{value:"Setting Up the Struct, Function, and Initializers",id:"setting-up-the-struct-function-and-initializers",level:4},{value:"Update Process",id:"update-process",level:4},{value:"Tests for the Updater",id:"tests-for-the-updater",level:4},{value:"Fetching the Current Record",id:"fetching-the-current-record",level:4},{value:"Checking For a Stale/Invalid ETag",id:"checking-for-a-staleinvalid-etag",level:4},{value:"Merging the Current Model with Desired Changes",id:"merging-the-current-model-with-desired-changes",level:4},{value:"Validating Updater Input",id:"validating-updater-input",level:4},{value:"Updating the Pet",id:"updating-the-pet",level:4},{value:"Final <code>pet_updater.go</code>",id:"final-pet_updatergo",level:4}],c={toc:l},d="wrapper";function u(e){let{components:t,...n}=e;return(0,a.kt)(d,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"implementation"},"Implementation"),(0,a.kt)("p",null,"Now we can start implementing our service objects. We'll start with the creator service object and then work on the\nupdater service object."),(0,a.kt)("h2",{id:"pet-creator"},(0,a.kt)("inlineCode",{parentName:"h2"},"Pet")," Creator"),(0,a.kt)("p",null,"In the ",(0,a.kt)("inlineCode",{parentName:"p"},"services/pet")," subpackage, we'll add two new files, ",(0,a.kt)("inlineCode",{parentName:"p"},"pet_creator.go")," and its corresponding tests file,",(0,a.kt)("br",{parentName:"p"}),"\n",(0,a.kt)("inlineCode",{parentName:"p"},"pet_creator_test.go"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text",metastring:"{6,7}","{6,7}":!0},"mymove/\n\u251c\u2500\u2500 pkg/\n\u2502   \u251c\u2500\u2500 services/\n\u2502   \u2502   \u251c\u2500\u2500 ...\n\u2502   \u2502   \u251c\u2500\u2500 pet/\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 pet_creator.go\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 pet_creator_test.go\n\u2502   \u2502   \u2502   \u251c\u2500\u2500 ...\n\u2502   \u2502   \u251c\u2500\u2500 ...\n")),(0,a.kt)("h3",{id:"creating-the-struct"},"Creating the Struct"),(0,a.kt)("p",null,"In the ",(0,a.kt)("inlineCode",{parentName:"p"},"pet_creator.go")," file, we'll start by defining our base ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," type for the service object. All of a\nservice objects' actions will be receiver functions for the ",(0,a.kt)("inlineCode",{parentName:"p"},"struct"),". This ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," should be private to the subpackage."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_creator.go"',title:'"pkg/services/pet/pet_creator.go"'},"package pet\n\n// petCreator is the concrete struct implementing the services.PetCreator interface\ntype petCreator struct {}\n")),(0,a.kt)("p",null,"This struct should contain all the required fields for your new service. Commonly this includes the validator\nfunctions for the service and possibly other service objects if they are needed. You should think of these fields as\n",(0,a.kt)("em",{parentName:"p"},"dependencies")," for your new service object. The more you have, the more work the caller will have to do to set up\nthis service, which can get inconvenient very quickly. Typically, these dependencies will be interfaces, which makes\nit easier to mock them in tests at least."),(0,a.kt)("p",null,"Note that the service objects that you need to define here are the ones that your service object will use directly,\nthey aren't the ones your validation functions will need. We'll see later how we pass the validators their dependencies. "),(0,a.kt)("p",null,"For the creator, we won't need any services to be part of the ",(0,a.kt)("inlineCode",{parentName:"p"},"struct"),". So for now, we'll just add a field for our\nvalidators:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_creator.go"',title:'"pkg/services/pet/pet_creator.go"'},"package pet\n\n// petCreator is the concrete struct implementing the services.PetCreator interface\ntype petCreator struct {\n    checks []petValidator\n}\n")),(0,a.kt)("h3",{id:"creating-the-action-function"},"Creating the Action Function"),(0,a.kt)("p",null,"Now that we've defined our ",(0,a.kt)("inlineCode",{parentName:"p"},"struct"),", we can define the receiver function for it. Remember that we intend for this\n",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," to be the implementation of the interface we defined in ",(0,a.kt)("inlineCode",{parentName:"p"},"services/pet.go"),", so we actually already defined\nthe signature for it when ",(0,a.kt)("a",{parentName:"p",href:"set-up-service-subpackage-and-interface#service-interface"},"we defined the interface"),".\nSo, that gives us this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_creator.go" {13-16}',title:'"pkg/services/pet/pet_creator.go"',"{13-16}":!0},'package pet\n\nimport (\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/models"\n)\n\n// petCreator is the concrete struct implementing the services.PetCreator interface\ntype petCreator struct {\n    checks []petValidator\n}\n\n// CreatePet creates a pet\nfunc (c *petCreator) CreatePet(appCtx appcontext.AppContext, pet models.Pet) (*models.Pet, error) {\n    return nil, nil  // TODO: implement logic\n}\n')),(0,a.kt)("p",null,"We'll come back and implement the logic in a later step."),(0,a.kt)("h3",{id:"creating-an-instance-of-our-service-object"},"Creating An Instance of Our Service Object"),(0,a.kt)("p",null,"We have a service object, and we have validators, but now we need a way to initialize our service objects and define\nhow we set up its validators, ensuring the correct ones are used as needed."),(0,a.kt)("p",null,"We'll use functions to initialize our service object with the correct validators for the use cases we have. When we\n",(0,a.kt)("a",{parentName:"p",href:"validation#grouping-rules-functions"},"grouped our validation functions"),", we defined what our use cases were, one\nfor the customer, and one for the office. We can create the corresponding initializing functions now:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_creator.go" {14-27}',title:'"pkg/services/pet/pet_creator.go"',"{14-27}":!0},'package pet\n\nimport (\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// petCreator is the concrete struct implementing the services.PetCreator interface\ntype petCreator struct {\n    checks []petValidator\n}\n\n// NewCustomerPetCreator creates a new petCreator struct with the checks it needs for a customer and the service\n// dependencies the checks need.\nfunc NewCustomerPetCreator(stringChecker services.StringChecker) services.PetCreator {\n    return &petCreator{\n        checks: customerChecks(stringChecker),\n    }\n}\n\n// NewOfficePetCreator creates a new petCreator struct with the checks it needs for an office user\nfunc NewOfficePetCreator() services.PetCreator {\n    return &petCreator{\n        checks: officeChecks(),\n    }\n}\n\n// CreatePet creates a pet\nfunc (c *petCreator) CreatePet(appCtx appcontext.AppContext, pet models.Pet) (*models.Pet, error) {\n    return nil, nil // TODO: implement logic\n}\n')),(0,a.kt)("p",null,"Here you can see in the ",(0,a.kt)("inlineCode",{parentName:"p"},"NewCustomerPetCreator")," how we pass along the ",(0,a.kt)("inlineCode",{parentName:"p"},"services.StringChecker")," that the checks need."),(0,a.kt)("p",null,"You'll notice we don't allow the caller to choose the checks that will be run for a given service. Instead, the\ncaller will need to pick the correct initializing function to use. This makes it so that we have uniform checks for\na given use case."),(0,a.kt)("p",null,"Using this strategy, we can add however many ",(0,a.kt)("inlineCode",{parentName:"p"},"New<UseCase><ServiceObject>")," functions as we need to. They will all\nreturn the same service interface with different validators. This way we don't have to muddle with our interface\ndefinition, which is great because every modification to an interface has to be reproduced with every ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," that\nimplements that interface. Creating new initializer functions is the least invasive way to change up our validation."),(0,a.kt)("p",null,"These functions also let us keep our ",(0,a.kt)("inlineCode",{parentName:"p"},"struct")," and dependencies private to this subpackage and helps us standardize\nthe way folks use our service. By abstracting implementation and returning an interface, we are creating boundaries\nbetween functionality and implementation that allow our codebase to be more flexible."),(0,a.kt)("h3",{id:"implementing-the-creator"},"Implementing the Creator"),(0,a.kt)("p",null,"Now that everything is set up and wired up, we can focus on the implementation details. ",(0,a.kt)("strong",{parentName:"p"},"This is going to be highly\ncontext-dependent.")," Keep in mind that the following guidance may not apply to your use case."),(0,a.kt)("p",null,"For creating a new model record, we generally need to:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Find any related objects in the database.",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Immediately we have a step that isn't applicable to the example model we're working with. Our ",(0,a.kt)("inlineCode",{parentName:"li"},"Pet")," is\nrelated to ",(0,a.kt)("inlineCode",{parentName:"li"},"Cat"),", but won't be creating it or affecting it in any way. But, if you were working with say,\ncreating a shipment, you'd need to find the move. We'll see an example of finding data we need when we work\non the ",(0,a.kt)("inlineCode",{parentName:"li"},"Pet")," updater though."))),(0,a.kt)("li",{parentName:"ol"},"Validate the input data against our business rules."),(0,a.kt)("li",{parentName:"ol"},"Start a transaction and make the change to the database."),(0,a.kt)("li",{parentName:"ol"},"Return the successfully created object.")),(0,a.kt)("h4",{id:"tests-for-the-creator"},"Tests for the Creator"),(0,a.kt)("p",null,"Knowing the general actions we'll take, we can write some tests for our creator, so we know we've set it up correctly."),(0,a.kt)("p",null,"Test cases we'll want:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Validation error with the input data"),(0,a.kt)("li",{parentName:"ul"},"Error with creating the ",(0,a.kt)("inlineCode",{parentName:"li"},"Pet")),(0,a.kt)("li",{parentName:"ul"},"Successfully creating a ",(0,a.kt)("inlineCode",{parentName:"li"},"Pet"))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Tests for `CreatePet`"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_creator_test.go"',title:'"pkg/services/pet/pet_creator_test.go"'},'package pet\n\nimport (\n    "github.com/gofrs/uuid"\n    "github.com/transcom/mymove/pkg/apperror"\n    "github.com/transcom/mymove/pkg/models"\n)\n\nfunc (suite PetSuite) TestCreatePet() {\n    // Only going to use one of our creators since the only difference between them is the rules they use for\n    // validation. Since the rules have their own tests and aren\'t the focus of these tests, no point in testing them.\n\n    suite.Run("Returns an InvalidInputError if there\'s an issue with the input data", func() {\n        badPet := models.Pet{\n            ID: uuid.Must(uuid.NewV4()),\n        }\n\n        creator := NewOfficePetCreator()\n\n        newPet, err := creator.CreatePet(suite.AppContextForTest(), badPet)\n\n        suite.Nil(newPet)\n\n        if suite.Error(err) {\n            suite.IsType(apperror.InvalidInputError{}, err)\n            suite.Equal(err.Error(), "Invalid input found while validating the pet.")\n        }\n    })\n\n    suite.Run("Returns a transaction error if one is raised", func() {\n        // Easiest way to trigger this is by trying to store a pet with the same ID. We\'ll also need to skip the\n        // validation for the first one so we\'ll create it directly\n        pet := models.Pet{\n            Type: models.PetTypeCat,\n            Name: "Fluffy",\n        }\n\n        appCtx := suite.AppContextForTest()\n\n        verrs, err := appCtx.DB().ValidateAndCreate(&pet)\n\n        suite.NoVerrs(verrs)\n        suite.Nil(err)\n        suite.NotNil(pet.ID)\n\n        creator := petCreator{}\n\n        newPet, createErr := creator.CreatePet(appCtx, pet)\n\n        suite.Nil(newPet)\n\n        if suite.Error(createErr) {\n            suite.IsType(apperror.QueryError{}, createErr)\n        }\n    })\n\n    suite.Run("Can successfully create a pet", func() {\n        pet := models.Pet{\n            Type: models.PetTypeCat,\n            Name: "Fluffy",\n        }\n\n        creator := NewOfficePetCreator()\n\n        newPet, err := creator.CreatePet(suite.AppContextForTest(), pet)\n\n        suite.Nil(err)\n\n        if suite.NotNil(newPet) {\n            suite.NotNil(newPet.ID)\n        }\n    })\n}\n'))),(0,a.kt)("p",null,"If we run those tests, they should all fail, but soon we'll get them passing!"),(0,a.kt)("h4",{id:"validating-creator-input"},"Validating Creator Input"),(0,a.kt)("p",null,"We can finally use the ",(0,a.kt)("inlineCode",{parentName:"p"},"validatePet")," function we wrote in the\n",(0,a.kt)("a",{parentName:"p",href:"validation#create-the-validatemodel-function"},"validation section"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_creator.go"',title:'"pkg/services/pet/pet_creator.go"'},'package pet\n\nimport (\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// petCreator is the concrete struct implementing the services.PetCreator interface\ntype petCreator struct {\n    checks []petValidator\n}\n\n// NewCustomerPetCreator creates a new petCreator struct with the checks it needs for a customer and the service\n// dependencies the checks need.\nfunc NewCustomerPetCreator(stringChecker services.StringChecker) services.PetCreator {\n    return &petCreator{\n        checks: customerChecks(stringChecker),\n    }\n}\n\n// NewOfficePetCreator creates a new petCreator struct with the checks it needs for an office user\nfunc NewOfficePetCreator() services.PetCreator {\n    return &petCreator{\n        checks: officeChecks(),\n    }\n}\n\n// CreatePet creates a pet\nfunc (c *petCreator) CreatePet(appCtx appcontext.AppContext, pet models.Pet) (*models.Pet, error) {\n    // highlight-start\n    err := validatePet(appCtx, pet, nil, c.checks...)\n\n    if err != nil {\n        return nil, err\n    }\n    // highlight-end\n\n    return nil, nil  // TODO: Finish implementing logic\n}\n')),(0,a.kt)("p",null,"You can see that we pass the ",(0,a.kt)("inlineCode",{parentName:"p"},"appCtx")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"pet")," along to ",(0,a.kt)("inlineCode",{parentName:"p"},"validatePet")," for the first two args. We then pass ",(0,a.kt)("inlineCode",{parentName:"p"},"nil"),"\nfor the third arg since we're creating a ",(0,a.kt)("inlineCode",{parentName:"p"},"Pet")," so there is no pre-existing ",(0,a.kt)("inlineCode",{parentName:"p"},"Pet"),". "),(0,a.kt)("p",null,"The final bit is to pass the checks that we want to use. Notice how we use ",(0,a.kt)("inlineCode",{parentName:"p"},"c.checks...")," to pass the checks. This is\nbecause the ",(0,a.kt)("inlineCode",{parentName:"p"},"checks")," will contain the correct checks based on how the ",(0,a.kt)("inlineCode",{parentName:"p"},"petCreator")," was initialized (\n",(0,a.kt)("inlineCode",{parentName:"p"},"NewCustomerPetCreator")," vs ",(0,a.kt)("inlineCode",{parentName:"p"},"NewOfficePetCreator"),"), and the ",(0,a.kt)("inlineCode",{parentName:"p"},"...")," part is because it's a variadic function (more info in\n",(0,a.kt)("a",{parentName:"p",href:"validation#resources"},"validation resources"),")."),(0,a.kt)("p",null,"The final bit for this part is to check for errors and return early if we have any."),(0,a.kt)("h4",{id:"creating-the-pet"},"Creating the Pet"),(0,a.kt)("p",null,"Next we'll start a transaction so that we can roll back the operation if there are issues. Within the transaction,\nwe'll use ",(0,a.kt)("a",{parentName:"p",href:"https://gobuffalo.io/en/docs/db/mutations/"},"Pop")," to create the ",(0,a.kt)("inlineCode",{parentName:"p"},"Pet"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_creator.go"',title:'"pkg/services/pet/pet_creator.go"'},'package pet\n\nimport (\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// Omitting the other parts for ease of reading\n\n// CreatePet creates a pet\nfunc (c *petCreator) CreatePet(appCtx appcontext.AppContext, pet models.Pet) (*models.Pet, error) {\n    err := validatePet(appCtx, pet, nil, c.checks...)\n\n    if err != nil {\n        return nil, err\n    }\n\n    // highlight-start\n    txnErr := appCtx.NewTransaction(func(txnCtx appcontext.AppContext) error {\n        // TODO: Implement creation logic\n        return nil\n    })\n\n    if txnErr != nil {\n        return nil, txnErr\n    }\n    // highlight-end\n    \n    return nil, nil  // TODO: Finish implementing logic\n}\n')),(0,a.kt)("p",null,"Here we can see we start a transaction which can return an error, so we need to catch that, check it, and if not\n",(0,a.kt)("inlineCode",{parentName:"p"},"nil"),", return it."),(0,a.kt)("p",null,"Within the transaction, it's important to use the ",(0,a.kt)("inlineCode",{parentName:"p"},"txnCtx")," version of ",(0,a.kt)("inlineCode",{parentName:"p"},"appcontext.AppContext"),". This ensures that if\nwe are within a larger transaction (e.g. an orchestrator service object is calling several service objects that\ncreate/update data), we can see the other changes that have been made as part of the transaction and vice versa."),(0,a.kt)("p",null,"Now we fill in the creation logic:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_creator.go"',title:'"pkg/services/pet/pet_creator.go"'},'package pet\n\nimport (\n    "github.com/gofrs/uuid"\n\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/apperror"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// Omitting the other parts for ease of reading\n\n// CreatePet creates a pet\nfunc (c *petCreator) CreatePet(appCtx appcontext.AppContext, pet models.Pet) (*models.Pet, error) {\n    err := validatePet(appCtx, pet, nil, c.checks...)\n\n    if err != nil {\n        return nil, err\n    }\n\n    txnErr := appCtx.NewTransaction(func(txnCtx appcontext.AppContext) error {\n        // highlight-start\n        // This will make the changes directly (if successful) using the pointer so we can just use `pet` later on.\n        verrs, err := txnCtx.DB().ValidateAndCreate(&pet)\n\n        // Check validation errors.\n        if verrs != nil && verrs.HasAny() {\n            return apperror.NewInvalidInputError(uuid.Nil, err, verrs, "Invalid input found while creating the Pet.")\n        } else if err != nil {\n            // If the error is something else (this is unexpected), we create a QueryError\n            return apperror.NewQueryError("Pet", err, "")\n        }\n        \n        return nil\n        // highlight-end\n    })\n\n    if txnErr != nil {\n        return nil, txnErr\n    }\n    \n    return nil, nil  // TODO: Finish implementing logic\n}\n')),(0,a.kt)("p",null,"We use ",(0,a.kt)("inlineCode",{parentName:"p"},"txnCtx.DB().ValidateAndCreate")," to actually create the ",(0,a.kt)("inlineCode",{parentName:"p"},"Pet"),", and check the validation errors and regular\nerror that we can get back. We have a pattern of converting unexpected (non-validation) errors into a\n",(0,a.kt)("inlineCode",{parentName:"p"},"apperror.QueryError")," type, but we don't want to override the error msg, hence the third arg being an empty string."),(0,a.kt)("h4",{id:"final-pet_creatorgo"},"Final ",(0,a.kt)("inlineCode",{parentName:"h4"},"pet_creator.go")),(0,a.kt)("p",null,"The last thing to do is return a pointer to the newly created ",(0,a.kt)("inlineCode",{parentName:"p"},"Pet"),", which gives us this final version:"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Final `pet_creator.go`"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_creator.go"',title:'"pkg/services/pet/pet_creator.go"'},'package pet\n\nimport (\n    "github.com/gofrs/uuid"\n\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/apperror"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// petCreator is the concrete struct implementing the services.PetCreator interface\ntype petCreator struct {\n    checks []petValidator\n}\n\n// NewCustomerPetCreator creates a new petCreator struct with the checks it needs for a customer and the service\n// dependencies the checks need.\nfunc NewCustomerPetCreator(stringChecker services.StringChecker) services.PetCreator {\n    return &petCreator{\n        checks: customerChecks(stringChecker),\n    }\n}\n\n// NewOfficePetCreator creates a new petCreator struct with the checks it needs for an office user\nfunc NewOfficePetCreator() services.PetCreator {\n    return &petCreator{\n        checks: officeChecks(),\n    }\n}\n\n// CreatePet creates a pet\nfunc (c *petCreator) CreatePet(appCtx appcontext.AppContext, pet models.Pet) (*models.Pet, error) {\n    err := validatePet(appCtx, pet, nil, c.checks...)\n\n    if err != nil {\n        return nil, err\n    }\n\n    txnErr := appCtx.NewTransaction(func(txnCtx appcontext.AppContext) error {\n        // This will make the changes directly (if successful) using the pointer so we can just use `pet` later on.\n        verrs, err := txnCtx.DB().ValidateAndCreate(&pet)\n\n        // Check validation errors.\n        if verrs != nil && verrs.HasAny() {\n            return apperror.NewInvalidInputError(uuid.Nil, err, verrs, "Invalid input found while creating the Pet.")\n        } else if err != nil {\n            // If the error is something else (this is unexpected), we create a QueryError\n            return apperror.NewQueryError("Pet", err, "")\n        }\n\n        return nil\n    })\n\n    if txnErr != nil {\n        return nil, txnErr\n    }\n\n    return &pet, nil\n}\n'))),(0,a.kt)("h3",{id:"implementing-the-updater"},"Implementing the Updater"),(0,a.kt)("p",null,"Next we can work on implementing the updater. ",(0,a.kt)("strong",{parentName:"p"},"This one is going to be highly context-dependent.")," Keep in mind\nthat the following guidance may not apply to your use case."),(0,a.kt)("h4",{id:"setting-up-the-struct-function-and-initializers"},"Setting Up the Struct, Function, and Initializers"),(0,a.kt)("p",null,"The steps here will be similar to the ",(0,a.kt)("inlineCode",{parentName:"p"},"Create")," version, so this section won't have as much explanation as the first\ntime."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_updater.go"',title:'"pkg/services/pet/pet_updater.go"'},'package pet\n\nimport (\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// petUpdater is the concrete struct implementing the services.PetUpdater interface\ntype petUpdater struct {\n    checks  []petValidator\n}\n\n// NewCustomerPetUpdater creates a new petUpdater struct with the checks it needs for a customer and the service\n// dependencies the checks need.\nfunc NewCustomerPetUpdater(stringChecker services.StringChecker) services.PetUpdater {\n    return &petUpdater{\n        checks: customerChecks(stringChecker),\n    }\n}\n\n// NewOfficePetUpdater creates a new petUpdater struct with the checks it needs for an office user\nfunc NewOfficePetUpdater() services.PetUpdater {\n    return &petUpdater{\n        checks: officeChecks(),\n    }\n}\n\n// UpdatePet updates an existing pet\nfunc (u *petUpdater) UpdatePet(appCtx appcontext.AppContext, pet models.Pet, eTag string) (*models.Pet, error) {\n    return nil, nil // TODO: implement logic\n}\n')),(0,a.kt)("p",null,"One thing to note is that we're re-using our grouped rule functions. This is why we wrote the functions to be able\nto handle both the case of creating and updating. Now we can easily re-use them for both our creator and updater\nservice objects."),(0,a.kt)("h4",{id:"update-process"},"Update Process"),(0,a.kt)("p",null,"For updating model record, we generally need to:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Find any related objects in the database.",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"This means finding the current version of the record we're updating, as well as any related models."))),(0,a.kt)("li",{parentName:"ol"},"Check the input ",(0,a.kt)("inlineCode",{parentName:"li"},"eTag")," against the current model to ensure the user was looking at the latest version before\nmaking changes."),(0,a.kt)("li",{parentName:"ol"},"Create a version of the model that has the requested changes layered on top of the original data.",(0,a.kt)("ol",{parentName:"li"},(0,a.kt)("li",{parentName:"ol"},"Remember that in ",(0,a.kt)("a",{parentName:"li",href:"validation#variations-of-validate-signature"},"Variations of ",(0,a.kt)("inlineCode",{parentName:"a"},"Validate")," Signature")," we\nmentioned that there's different ways of approaching validation. Since we chose option 1 then, we need to\ncreate the merged new version ",(0,a.kt)("strong",{parentName:"li"},"before")," validating the data. If we'd chosen option 2, this step would be\nafter the next one."))),(0,a.kt)("li",{parentName:"ol"},"Validate the input data against our business rules."),(0,a.kt)("li",{parentName:"ol"},"Start a transaction and make the change to the database."),(0,a.kt)("li",{parentName:"ol"},"Return the successfully updated object.")),(0,a.kt)("h4",{id:"tests-for-the-updater"},"Tests for the Updater"),(0,a.kt)("p",null,"Knowing the general actions we'll take, we can write some tests for our updater, so we know we've set it up correctly."),(0,a.kt)("p",null,"Test cases we would want:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Error if original ",(0,a.kt)("inlineCode",{parentName:"li"},"Pet")," can't be found"),(0,a.kt)("li",{parentName:"ul"},"Error if ",(0,a.kt)("inlineCode",{parentName:"li"},"eTag")," is stale/invalid"),(0,a.kt)("li",{parentName:"ul"},"Validation error with the input data"),(0,a.kt)("li",{parentName:"ul"},"Error with updating the ",(0,a.kt)("inlineCode",{parentName:"li"},"Pet"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Because of the way our ",(0,a.kt)("inlineCode",{parentName:"li"},"Pet")," model is set up, there isn't really an easy way to test this case, so we'll skip\nthis one."))),(0,a.kt)("li",{parentName:"ul"},"Successfully updating a ",(0,a.kt)("inlineCode",{parentName:"li"},"Pet")),(0,a.kt)("li",{parentName:"ul"},"Returns associated models.",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"This will depend a lot on what you're trying to do. You may not have related data, or you may not need to pass\nit back out.")))),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Tests for `UpdatePet`"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_updater_test.go"',title:'"pkg/services/pet/pet_updater_test.go"'},'package pet\n\nimport (\n    "errors"\n    "fmt"\n\n    "github.com/gofrs/uuid"\n    "github.com/stretchr/testify/mock"\n\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/apperror"\n    "github.com/transcom/mymove/pkg/etag"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services/mocks"\n    "github.com/transcom/mymove/pkg/testdatagen"\n)\n\nfunc (suite PetSuite) TestUpdateCat() {\n    setUpForTest := func(appCtx appcontext.AppContext, overrides *models.Pet) *models.Pet {\n        originalPet := models.Pet{\n            Type: models.PetTypeDog,\n            Name: "Fluffy",\n        }\n\n        if overrides != nil {\n            testdatagen.MergeModels(&originalPet, overrides)\n        }\n\n        verrs, err := appCtx.DB().ValidateAndCreate(&originalPet)\n\n        suite.NoVerrs(verrs)\n        suite.Nil(err)\n        suite.NotNil(originalPet.ID)\n\n        return &originalPet\n    }\n\n    suite.Run("Returns an error if the original ", func() {\n        // Since we haven\'t created any Pets, we\'ll just use a randomly generated ID that we\'ll try searching for.\n        badPet := models.Pet{\n            ID: uuid.Must(uuid.NewV4()),\n        }\n\n        updater := NewOfficePetUpdater()\n\n        updatedPet, err := updater.UpdatePet(suite.AppContextForTest(), badPet, "")\n\n        suite.Nil(updatedPet)\n\n        if suite.Error(err) {\n            suite.IsType(apperror.NotFoundError{}, err)\n\n            suite.Equal(\n                fmt.Sprintf("ID: %s not found while looking for Pet", badPet.ID.String()),\n                err.Error(),\n            )\n        }\n    })\n\n    suite.Run("Returns a PreconditionFailedError if the input eTag is stale/incorrect", func() {\n        appCtx := suite.AppContextForTest()\n\n        originalPet := setUpForTest(appCtx, nil)\n\n        updater := NewOfficePetUpdater()\n\n        updatedPet, updateErr := updater.UpdatePet(suite.AppContextForTest(), *originalPet, "")\n\n        suite.Nil(updatedPet)\n\n        if suite.Error(updateErr) {\n            suite.IsType(apperror.PreconditionFailedError{}, updateErr)\n\n            suite.Equal(\n                fmt.Sprintf("Precondition failed on update to object with ID: \'%s\'. The If-Match header value did not match the eTag for this record.", originalPet.ID.String()),\n                updateErr.Error(),\n            )\n        }\n    })\n\n    suite.Run("Returns an InvalidInputError if there\'s an issue with the input data", func() {\n        appCtx := suite.AppContextForTest()\n\n        originalPet := setUpForTest(appCtx, nil)\n\n        badPet := *originalPet\n        badPet.Name = "<Hacked>"\n\n        stringCheckError := errors.New("invalid characters found in string")\n\n        stringChecker := mocks.NewStringChecker(suite.T())\n\n        stringChecker.On("Validate",\n            mock.AnythingOfType("*appcontext.appContext"),\n            mock.AnythingOfType("string"),\n        ).Return(stringCheckError)\n\n        updater := NewCustomerPetUpdater(stringChecker)\n\n        updatedPet, updateErr := updater.UpdatePet(suite.AppContextForTest(), badPet, etag.GenerateEtag(originalPet.UpdatedAt))\n\n        suite.Nil(updatedPet)\n\n        if suite.Error(updateErr) {\n            suite.IsType(apperror.InvalidInputError{}, updateErr)\n\n            suite.Equal("Invalid input found while validating the pet.", updateErr.Error())\n        }\n    })\n\n    suite.Run("Can successfully update a pet", func() {\n        appCtx := suite.AppContextForTest()\n\n        originalPet := setUpForTest(appCtx, nil)\n\n        desiredPet := *originalPet\n        desiredPet.Name = "Cheddar"\n\n        updater := NewOfficePetUpdater()\n\n        updatedPet, updateErr := updater.UpdatePet(suite.AppContextForTest(), desiredPet, etag.GenerateEtag(originalPet.UpdatedAt))\n\n        suite.Nil(updateErr)\n\n        if suite.NotNil(updatedPet) {\n            suite.Equal(desiredPet.Name, updatedPet.Name)\n        }\n    })\n\n    suite.Run("Returns associated child models", func() {\n        appCtx := suite.AppContextForTest()\n\n        originalPet := setUpForTest(appCtx, &models.Pet{Type: models.PetTypeCat})\n\n        desiredPet := *originalPet\n        desiredPet.Name = "Cheddar"\n        eTag := etag.GenerateEtag(originalPet.UpdatedAt)\n\n        updater := NewOfficePetUpdater()\n\n        updatedPet, updateErr := updater.UpdatePet(suite.AppContextForTest(), desiredPet, eTag)\n\n        suite.Nil(updateErr)\n\n        if suite.NotNil(updatedPet) {\n            suite.Equal(desiredPet.Name, updatedPet.Name)\n\n            suite.NotNil(updatedPet.Cat)\n        }\n    })\n}\n'))),(0,a.kt)("p",null,"If we run those tests, they should all fail, but soon we'll get them passing!"),(0,a.kt)("h4",{id:"fetching-the-current-record"},"Fetching the Current Record"),(0,a.kt)("p",null,"The first thing we'll want to do is search for the current version of this model. The exact query will vary based on\nwhat info you need, but for this one, it will look like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_updater.go"',title:'"pkg/services/pet/pet_updater.go"'},'package pet\n\nimport (\n    "database/sql"\n    \n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/apperror"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// Omitting the other parts for ease of reading\n\n// UpdatePet creates a pet\nfunc (u *petUpdater) UpdatePet(appCtx appcontext.AppContext, pet models.Pet, eTag string) (*models.Pet, error) {\n    // highlight-start\n    originalPet := models.Pet{}\n\n    if err := appCtx.DB().Eager().Find(&originalPet, pet.ID); err != nil {\n        switch err {\n        case sql.ErrNoRows:\n            return nil, apperror.NewNotFoundError(pet.ID, "while looking for Pet")\n        default:\n            return nil, apperror.NewQueryError("Pet", err, "")\n        }\n    }\n    // highlight-end\n\n    return nil, nil // TODO: implement logic\n}\n')),(0,a.kt)("p",null,"Note that we want to load the associated models too so that when we return the final version, it has all the\nnecessary related data. If you don't need the extra data, you can skip that part. There are also performance\nconsiderations for using ",(0,a.kt)("inlineCode",{parentName:"p"},"Eager")," vs ",(0,a.kt)("inlineCode",{parentName:"p"},"EagerPreload"),", but we can't use the latter here due to a bug. You can see more\ninfo in ",(0,a.kt)("a",{parentName:"p",href:"/docs/backend/setup/using-eagerpreload-in-pop"},"Using EagerPreload in Pop"),"."),(0,a.kt)("h4",{id:"checking-for-a-staleinvalid-etag"},"Checking For a Stale/Invalid ETag"),(0,a.kt)("p",null,"Now we want to make sure that the ",(0,a.kt)("inlineCode",{parentName:"p"},"eTag")," associated with the version of the data that the user wants to update is\nstill the latest version. Otherwise, the updates this user requested might accidentally overwrite another user's\nupdates."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_updater.go"',title:'"pkg/services/pet/pet_updater.go"'},'package pet\n\nimport (\n    "database/sql"\n    \n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/apperror"\n    "github.com/transcom/mymove/pkg/etag"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// Omitting the other parts for ease of reading\n\n// UpdatePet creates a pet\nfunc (u *petUpdater) UpdatePet(appCtx appcontext.AppContext, pet models.Pet, eTag string) (*models.Pet, error) {\n    originalPet := models.Pet{}\n\n    if err := appCtx.DB().Find(&originalPet, pet.ID); err != nil {\n        switch err {\n        case sql.ErrNoRows:\n            return nil, apperror.NewNotFoundError(pet.ID, "while looking for Pet")\n        default:\n            return nil, apperror.NewQueryError("Pet", err, "")\n        }\n    }\n\n    if originalPet.Type == models.PetTypeCat {\n        if err := appCtx.DB().Load(&originalPet, "Cat"); err != nil {\n            return nil, apperror.NewQueryError("Pet", err, "")\n        }\n    }\n\n    // highlight-start\n    if etag.GenerateEtag(originalPet.UpdatedAt) != eTag {\n        return nil, apperror.NewPreconditionFailedError(originalPet.ID, nil)\n    }\n    // highlight-end\n\n    return nil, nil // TODO: implement logic\n}\n')),(0,a.kt)("h4",{id:"merging-the-current-model-with-desired-changes"},"Merging the Current Model with Desired Changes"),(0,a.kt)("p",null,"Next we'll merge the current model and the desired changes to get the final state that we can then validate:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_updater.go"',title:'"pkg/services/pet/pet_updater.go"'},'package pet\n\nimport (\n    "database/sql"\n    \n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/apperror"\n    "github.com/transcom/mymove/pkg/etag"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// Omitting the other parts for ease of reading\n\n// UpdatePet creates a pet\nfunc (u *petUpdater) UpdatePet(appCtx appcontext.AppContext, pet models.Pet, eTag string) (*models.Pet, error) {\n    originalPet := models.Pet{}\n\n    if err := appCtx.DB().Find(&originalPet, pet.ID); err != nil {\n        switch err {\n        case sql.ErrNoRows:\n            return nil, apperror.NewNotFoundError(pet.ID, "while looking for Pet")\n        default:\n            return nil, apperror.NewQueryError("Pet", err, "")\n        }\n    }\n\n    if originalPet.Type == models.PetTypeCat {\n        if err := appCtx.DB().Load(&originalPet, "Cat"); err != nil {\n            return nil, apperror.NewQueryError("Pet", err, "")\n        }\n    }\n\n    if etag.GenerateEtag(originalPet.UpdatedAt) != eTag {\n        return nil, apperror.NewPreconditionFailedError(originalPet.ID, nil)\n    }\n\n    // highlight-start\n    // First we\'ll create a copy of the originalPet and make the changes to the new version.\n    newPet := originalPet\n\n    if pet.Type != "" {\n        newPet.Type = pet.Type\n    }\n\n    if pet.Name != "" {\n        newPet.Name = pet.Name\n    }\n\n    newPet.Birthday = services.SetOptionalDateTimeField(pet.Birthday, originalPet.Birthday)\n    newPet.GotchaDay = services.SetOptionalDateTimeField(pet.GotchaDay, originalPet.GotchaDay)\n    newPet.Bio = services.SetOptionalStringField(pet.Bio, originalPet.Bio)\n    newPet.Weight = services.SetOptionalPoundField(pet.Weight, originalPet.Weight)\n    // highlight-end\n\n    return nil, nil // TODO: implement logic\n}\n')),(0,a.kt)("p",null,"You'll see that we have some shared helper functions to deal with the logic for setting some types of optional\nfields. We also have some for required fields, but not for ",(0,a.kt)("inlineCode",{parentName:"p"},"Type")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"Name")," so we had to do those manually. As you\nwork on services, if you find that you're doing some type of logic repeatedly, feel free to add more helpers!"),(0,a.kt)("h4",{id:"validating-updater-input"},"Validating Updater Input"),(0,a.kt)("p",null,"Now we're ready to validate!"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_updater.go"',title:'"pkg/services/pet/pet_updater.go"'},'package pet\n\nimport (\n    "database/sql"\n    \n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/apperror"\n    "github.com/transcom/mymove/pkg/etag"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// Omitting the other parts for ease of reading\n\n// UpdatePet creates a pet\nfunc (u *petUpdater) UpdatePet(appCtx appcontext.AppContext, pet models.Pet, eTag string) (*models.Pet, error) {\n    // Omitting the rest of the logic to focus better\n    \n    // First we\'ll create a copy of the originalPet and make the changes to the new version.\n    newPet := originalPet\n\n    if pet.Type != "" {\n        newPet.Type = pet.Type\n    }\n\n    if pet.Name != "" {\n        newPet.Name = pet.Name\n    }\n\n    newPet.Birthday = services.SetOptionalDateTimeField(pet.Birthday, originalPet.Birthday)\n    newPet.GotchaDay = services.SetOptionalDateTimeField(pet.GotchaDay, originalPet.GotchaDay)\n    newPet.Bio = services.SetOptionalStringField(pet.Bio, originalPet.Bio)\n    newPet.Weight = services.SetOptionalPoundField(pet.Weight, originalPet.Weight)\n    \n    // highlight-start\n    if err := validatePet(appCtx, newPet, &originalPet, u.checks...); err != nil {\n        return nil, err\n    }\n    // highlight-end\n\n    return nil, nil // TODO: implement logic\n}\n')),(0,a.kt)("p",null,"You can see that unlike with the creator, we do pass in a third arg to ",(0,a.kt)("inlineCode",{parentName:"p"},"validatePet")," since we're doing updates this\ntime and do have an ",(0,a.kt)("inlineCode",{parentName:"p"},"originalPet"),"."),(0,a.kt)("h4",{id:"updating-the-pet"},"Updating the Pet"),(0,a.kt)("p",null,"Next we'll start a transaction so that we can roll back the operation if there are issues. Within the transaction,\nwe'll use ",(0,a.kt)("a",{parentName:"p",href:"https://gobuffalo.io/en/docs/db/mutations/"},"Pop")," to update the ",(0,a.kt)("inlineCode",{parentName:"p"},"Pet"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_updater.go"',title:'"pkg/services/pet/pet_updater.go"'},'package pet\n\nimport (\n    "database/sql"\n    \n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/apperror"\n    "github.com/transcom/mymove/pkg/etag"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// Omitting the other parts for ease of reading\n\n// UpdatePet creates a pet\nfunc (u *petUpdater) UpdatePet(appCtx appcontext.AppContext, pet models.Pet, eTag string) (*models.Pet, error) {\n    // Omitting the rest of the logic to focus better\n    \n    // highlight-start\n    txnErr := appCtx.NewTransaction(func(txnCtx appcontext.AppContext) error {\n        // This will make the changes directly (if successful) using the pointer so we can just use `newPet` later on.\n        verrs, err := txnCtx.DB().ValidateAndUpdate(&newPet)\n\n        // Check validation errors.\n        if verrs != nil && verrs.HasAny() {\n            return apperror.NewInvalidInputError(originalPet.ID, err, verrs, "invalid input found while updating the Pet")\n        } else if err != nil {\n            // If the error is something else (this is unexpected), we create a QueryError\n            return apperror.NewQueryError("Pet", err, "")\n        }\n\n        return nil\n    })\n\n    if txnErr != nil {\n        return nil, txnErr\n    }\n    // highlight-end\n}\n')),(0,a.kt)("p",null,"You'll notice the logic for the DB transaction is pretty similar to the logic for the creator. The main difference\nis the use of ",(0,a.kt)("inlineCode",{parentName:"p"},"txnCtx.DB().ValidateAndUpdate")," instead of ",(0,a.kt)("inlineCode",{parentName:"p"},"txnCtx.DB().ValidateAndCreate")),(0,a.kt)("h4",{id:"final-pet_updatergo"},"Final ",(0,a.kt)("inlineCode",{parentName:"h4"},"pet_updater.go")),(0,a.kt)("p",null,"And with that, we're done! Here's the final version of the updater:"),(0,a.kt)("details",null,(0,a.kt)("summary",null,"Final `pet_updater.go`"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-go",metastring:'title="pkg/services/pet/pet_updater.go"',title:'"pkg/services/pet/pet_updater.go"'},'package pet\n\nimport (\n    "database/sql"\n\n    "github.com/transcom/mymove/pkg/appcontext"\n    "github.com/transcom/mymove/pkg/apperror"\n    "github.com/transcom/mymove/pkg/etag"\n    "github.com/transcom/mymove/pkg/models"\n    "github.com/transcom/mymove/pkg/services"\n)\n\n// petUpdater is the concrete struct implementing the services.PetUpdater interface\ntype petUpdater struct {\n    checks []petValidator\n}\n\n// NewCustomerPetUpdater creates a new petUpdater struct with the checks it needs for a customer and the service\n// dependencies the checks need.\nfunc NewCustomerPetUpdater(stringChecker services.StringChecker) services.PetUpdater {\n    return &petUpdater{\n        checks: customerChecks(stringChecker),\n    }\n}\n\n// NewOfficePetUpdater creates a new petUpdater struct with the checks it needs for an office user\nfunc NewOfficePetUpdater() services.PetUpdater {\n    return &petUpdater{\n        checks: officeChecks(),\n    }\n}\n\n// UpdatePet creates a pet\nfunc (u *petUpdater) UpdatePet(appCtx appcontext.AppContext, pet models.Pet, eTag string) (*models.Pet, error) {\n    originalPet := models.Pet{}\n\n    if err := appCtx.DB().Eager().Find(&originalPet, pet.ID); err != nil {\n        switch err {\n        case sql.ErrNoRows:\n            return nil, apperror.NewNotFoundError(pet.ID, "while looking for Pet")\n        default:\n            return nil, apperror.NewQueryError("Pet", err, "")\n        }\n    }\n\n    if etag.GenerateEtag(originalPet.UpdatedAt) != eTag {\n        return nil, apperror.NewPreconditionFailedError(originalPet.ID, nil)\n    }\n\n    // First we\'ll create a copy of the originalPet and make the changes to the new version.\n    newPet := originalPet\n\n    if pet.Type != "" {\n        newPet.Type = pet.Type\n    }\n\n    if pet.Name != "" {\n        newPet.Name = pet.Name\n    }\n\n    newPet.Birthday = services.SetOptionalDateTimeField(pet.Birthday, originalPet.Birthday)\n    newPet.GotchaDay = services.SetOptionalDateTimeField(pet.GotchaDay, originalPet.GotchaDay)\n    newPet.Bio = services.SetOptionalStringField(pet.Bio, originalPet.Bio)\n    newPet.Weight = services.SetOptionalPoundField(pet.Weight, originalPet.Weight)\n\n    if err := validatePet(appCtx, newPet, &originalPet, u.checks...); err != nil {\n        return nil, err\n    }\n\n    txnErr := appCtx.NewTransaction(func(txnCtx appcontext.AppContext) error {\n        // This will make the changes directly (if successful) using the pointer so we can just use `newPet` later on.\n        verrs, err := txnCtx.DB().ValidateAndUpdate(&newPet)\n\n        // Check validation errors.\n        if verrs != nil && verrs.HasAny() {\n            return apperror.NewInvalidInputError(originalPet.ID, err, verrs, "invalid input found while updating the Pet")\n        } else if err != nil {\n            // If the error is something else (this is unexpected), we create a QueryError\n            return apperror.NewQueryError("Pet", err, "")\n        }\n\n        return nil\n    })\n\n    if txnErr != nil {\n        return nil, txnErr\n    }\n\n    return &newPet, nil\n}\n'))),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"Now that the function is filled out, you'll want to refactor it by extracting each logical step into a separate,\nsmaller, and well-named private function. We should strive to keep all functions as small as possible for\nreadability. The creator was much smaller, so it's not as vital to do that there, but as you can see, the updater is\nquite large by the end."),(0,a.kt)("p",{parentName:"admonition"},(0,a.kt)("a",{parentName:"p",href:"https://github.com/transcom/mymove/blob/main/pkg/services/mto_service_item/mto_service_item_updater.go#L44-L123"},"ApproveOrRejectServiceItem"),"\nis a good example of a function that performs a lot of actions, and each one is encapsulated in a separate function.")))}u.isMDXComponent=!0}}]);