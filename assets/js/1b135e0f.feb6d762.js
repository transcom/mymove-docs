"use strict";(self.webpackChunkmymove_docs=self.webpackChunkmymove_docs||[]).push([[3325],{66670:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>h,frontMatter:()=>l,metadata:()=>r,toc:()=>u});var o=a(87462),n=(a(67294),a(3905));a(8209);const l={title:"0082 Use Flipt for Feature Flags",description:'Feature Flags enable CI/CD and roll-forward recovery. The question isn\'t "why?", but "how?"'},i="Flipt Feature Flags to enable CI/CD and roll-forward recovery",r={unversionedId:"adrs/use-flipt-feature-flags",id:"adrs/use-flipt-feature-flags",title:"0082 Use Flipt for Feature Flags",description:'Feature Flags enable CI/CD and roll-forward recovery. The question isn\'t "why?", but "how?"',source:"@site/docs/adrs/0082-use-flipt-feature-flags.md",sourceDirName:"adrs",slug:"/adrs/use-flipt-feature-flags",permalink:"/mymove-docs/docs/adrs/use-flipt-feature-flags",draft:!1,editUrl:"https://github.com/transcom/mymove-docs/edit/main/docs/adrs/0082-use-flipt-feature-flags.md",tags:[],version:"current",sidebarPosition:82,frontMatter:{title:"0082 Use Flipt for Feature Flags",description:'Feature Flags enable CI/CD and roll-forward recovery. The question isn\'t "why?", but "how?"'},sidebar:"adrsSidebar",previous:{title:"0081 Use ASDF to Manage Node and Golang versions in Development",permalink:"/mymove-docs/docs/adrs/use-asdf-to-manage-node-and-golang-versions-in-development"}},s={},u=[{value:"Feature Flag Workflow",id:"feature-flag-workflow",level:3},{value:"Considered Alternatives",id:"considered-alternatives",level:2},{value:"Decision Outcome",id:"decision-outcome",level:2},{value:"Pros and Cons of the Alternatives",id:"pros-and-cons-of-the-alternatives",level:2},{value:"Option #0: Do Nothing",id:"option-0-do-nothing",level:3},{value:"Option #1: LaunchDarkly",id:"option-1-launchdarkly",level:3},{value:"Option #2: Unleash",id:"option-2-unleash",level:3},{value:"Option #3: AWS AppConfig",id:"option-3-aws-appconfig",level:3},{value:"Option #4: Roll our own",id:"option-4-roll-our-own",level:3},{value:"Option #5: Flipt",id:"option-5-flipt",level:3}],d={toc:u},p="wrapper";function h(e){let{components:t,...a}=e;return(0,n.kt)(p,(0,o.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"flipt-feature-flags-to-enable-cicd-and-roll-forward-recovery"},"Flipt Feature Flags to enable CI/CD and roll-forward recovery"),(0,n.kt)("p",null,(0,n.kt)("strong",{parentName:"p"},"User Story:")," MB-13752"),(0,n.kt)("p",null,"Why do this?"),(0,n.kt)("p",null,"In production, USTC is going to expect very fast turnaround on some changes (hopefully mostly bugs). As they also have a long list of features to be added after go-live, it is likely that an incomplete feature will be committed when a fix is needed, and completing that feature would add an unacceptable delay to shipping the fix."),(0,n.kt)("p",null,"There are a few different approaches to solving this problem, depending on which decade you\u2019re in. During the 2020s, the industry generally uses feature flags, so that is the type of solution considered here.\nThe other thing that feature flags allow, that would be very difficult otherwise, is segmenting the user base. Say for example that several months after we are live, we need to stop using login.gov and start using Okta. We could pick a date, and after that date require everyone to just set up a new login to get to their existing data. This would be inconsiderate at least, and a less-than-delightful user experience for people who happen to be in the middle of moving their entire family across the country on that date. Instead of that very bad scenario, we can use feature flags to have both login methods enabled at the same time, and select which one to use depending on the user. New users approaching the system can be directed to Okta, while existing users can continue to use login.gov. After all of the login.gov users have completed their moves, the feature can be turned off, and then later removed if needed. This approach can be used for any change, as needed."),(0,n.kt)("p",null,"The chosen solution should:"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Not disrupt the existing engineering workflow without good reason"),(0,n.kt)("li",{parentName:"ul"},"Be respectful of budgetary concerns"),(0,n.kt)("li",{parentName:"ul"},"Improve our ability to deliver code"),(0,n.kt)("li",{parentName:"ul"},"Solve all of the problem scenarios below"),(0,n.kt)("li",{parentName:"ul"},"Minimize impact on the already tight Milestone 1 schedule")),(0,n.kt)("p",null,"Problem Statement"),(0,n.kt)("p",null,"The MilMove project has multiple teams pushing code to shared repositories. All teams are currently using the same branch in each repo: main. This is very efficient pre-production, because all teams see each others' changes quickly. When we go to production (and maybe even a little before), this breaks down. A couple of example scenarios will illustrate this:"),(0,n.kt)("p",null,"Scenario 1: The Bug vs. The Incomplete Feature"),(0,n.kt)("p",null,"While one of our teams is part-way through an epic that adds a new feature, a critical bug is reported. A fix for the bug is quickly found and committed. But if we deploy code from the main branch at that point, half of the new feature will also be included, since it was already committed. Releasing half of a feature to production is generally frowned upon."),(0,n.kt)("p",null,"Scenario 2: Changing Authentication"),(0,n.kt)("p",null,"After we have been live for several months, the customer requires us to move from using login.gov to authenticate users to Okta. Writing and testing the code is no problem. But when we deploy it, every user now has to set up a new authentication account. Many of those users will be in the middle of moving to their next duty station when we spring this on them. Users are constantly moving, there will not be a break in the schedule where we can do the changeover."),(0,n.kt)("p",null,"Scenario 3: Prime Freeze"),(0,n.kt)("p",null,"For 30 days before we go live, the Prime (HSA) requires a code freeze for testing. We do not want to stop deploying for 30 days, and we really don't want to stop development for 30 days. Feature flags would allow us to build and deploy code during the freeze and remain productive."),(0,n.kt)("h3",{id:"feature-flag-workflow"},"Feature Flag Workflow"),(0,n.kt)("p",null,"The ",(0,n.kt)("a",{parentName:"p",href:"https://launchdarkly.com/blog/what-are-feature-flags/"},"launch darkly overview of feature flags")," is a good summary of what feature flags can do."),(0,n.kt)("p",null,"Imagine MilMove is being used daily in production. Further, imagine we are adding new functionality to MilMove. We need to make schema changes, backend changes, and frontend changes. We want to be able test all aspects of the feature before releasing it for general availability."),(0,n.kt)("p",null,"We want a way where we can hide this new functionality until is is ready, but we don't want to have to have a separate branch in git and wait to merge all this code into main. We want to separate the release of the feature from the deployment of the code."),(0,n.kt)("p",null,"Suppose we want to have a limited rollout in production and only want certain service members to have access to MilMove for setting up their move. We could add logic to the auth handlers in the backend that might look like"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},'// how we might allow only certain users to log into the\n// production environment when we are testing moves\n\nconst loginAllowedFlag = "loginAllowed"\n    flag, err := h.FeatureFlagFetcher().GetFlagForUser(r.Context(), appCtx, loginAllowedFlag, map[string]string{})\n    if err != nil {\n        // in this case, we will fail open in case of feature flag\n        // failure. The user has already been authenticated by login.gov\n        appCtx.Logger().Warn("Feature flag failure in auth handler", zap.Error(err))\n    } else {\n        if !flag.IsEnabledVariant() {\n            appCtx.Logger().Info("User does not have login flag enabled", zap.String("flag, loginEnabledFlag))\n            invalidPermissionsResponse(appCtx, h.HandlerConfig, h.Context, w, r)\n            return\n        }\n  }\n')),(0,n.kt)("p",null,"The feature flag service can use the information about the user to decide if they can log in."),(0,n.kt)("p",null,"Or imagine when we are implementing OCONUS moves, but we don't want to roll it out to all service members at once. Maybe we have something in the UI that presents different options."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-javascript"},"import { FeatureFlag, featureIsEnabled } from 'components/FeatureFlag/FeatureFlag';\n\n// ...\n\nexport const ConusOrNot = () => {\n  const enabledOconus = () => {\n    // something\n  }\n  const disabledOconus = () => {\n    // something\n  }\n  const featureFlagRender = (flagValue) => {\n    if (featureIsEnabled(flagValue)) {\n      return enabledOconus;\n    }\n    return disabledOconus;\n  };\n\n  return <FeatureFlag flagKey=\"service-member-oconus\" render={featureFlagRender} />;\n}\n")),(0,n.kt)("h2",{id:"considered-alternatives"},"Considered Alternatives"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Option #0: Do Nothing. Stay the course, don't make any changes, figure out what to do when problems arise"),(0,n.kt)("li",{parentName:"ul"},"Option #1: LaunchDarkly: This is the industry standard feature flag platform."),(0,n.kt)("li",{parentName:"ul"},"Option #2: Unleash: Open source, can be self-hosted"),(0,n.kt)("li",{parentName:"ul"},"Option #3: AWS AppConfig: we're already using lots of AWS, what's a little more?"),(0,n.kt)("li",{parentName:"ul"},"Option #4: Roll our own"),(0,n.kt)("li",{parentName:"ul"},"Option #5: Flipt: Open source, self hosted, supports file based config")),(0,n.kt)("h2",{id:"decision-outcome"},"Decision Outcome"),(0,n.kt)("p",null,"Chosen Alternative: Option #5: Flipt"),(0,n.kt)("p",null,"This section is an overview of why choose Flipt over the alternatives."),(0,n.kt)("p",null,"LaunchDarkly is the industry standard, but there is no room for it in the budget. Unleash has similar features to AWS AppConfig, but requires more setup and maintenance effort when self-hosted (e.g. it requires a PostgreSQL database). AWS AppConfig is really a thin shim over config files and doesn't provide much in the way of helping us manage feature groupings."),(0,n.kt)("p",null,"Rolling our own is a possibility, but one key feature we'd want to think about is how to promote feature flags from one environment to another (e.g. from staging to production). That suggests that tying the feature flag to the environment by e.g. storing the flags in the database isn't ideal as we need to recreate the flag settings in each environment. Combining that with the desire to have feature flags be enabled on a per user basis, it makes the complexity of rolling our own outweigh the relatively simple flipt deployment."),(0,n.kt)("p",null,"Flipt provides a ",(0,n.kt)("a",{parentName:"p",href:"https://www.flipt.io/docs/experimental/filesystem-backends"},"filesystem backend")," which would allow a way for us to manage our feature flags using a ",(0,n.kt)("a",{parentName:"p",href:"https://about.gitlab.com/topics/gitops/"},"gitops")," style process. We can test out our flag configuration in separate environments (e.g. experimental, demo, staging) before rolling out to production. It also allows us to deploy the Flipt service without requiring another stateful system (e.g. no database)."),(0,n.kt)("p",null,"We will have a couple of different options for how we deploy flipt. Examining the options for how flipt is deployed will be its own ADR."),(0,n.kt)("h2",{id:"pros-and-cons-of-the-alternatives"},"Pros and Cons of the Alternatives"),(0,n.kt)("h3",{id:"option-0-do-nothing"},"Option #0: Do Nothing"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"'+' No change to App Eng workflow"),(0,n.kt)("li",{parentName:"ul"},"'+' No additional work for Platform Team"),(0,n.kt)("li",{parentName:"ul"},"'-' We will at some point ship the wrong code that includes a half baked feature that wasn't meant for public use yet"),(0,n.kt)("li",{parentName:"ul"},"'-' Could break API versioning required by Prime and/or make it harder to make API changes")),(0,n.kt)("h3",{id:"option-1-launchdarkly"},"Option #1: ",(0,n.kt)("a",{parentName:"h3",href:"https://launchdarkly.com"},"LaunchDarkly")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"'+' Industry standard"),(0,n.kt)("li",{parentName:"ul"},"'+' Feature Rich"),(0,n.kt)("li",{parentName:"ul"},"'-' Expensive. No room in ODC budget"),(0,n.kt)("li",{parentName:"ul"},"'-' Might not be allowed (It is FedRAMP moderate, not IL4)"),(0,n.kt)("li",{parentName:"ul"},"'-' Unknown if Platform Team will need to be involved")),(0,n.kt)("h3",{id:"option-2-unleash"},"Option #2: ",(0,n.kt)("a",{parentName:"h3",href:"https://github.com/Unleash/unleash"},"Unleash")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"'+' Open Source"),(0,n.kt)("li",{parentName:"ul"},"'+' Can be self-hosted, so meets MilMove security requirements"),(0,n.kt)("li",{parentName:"ul"},"'-' Adds another thing for Platform to do before Milestone 1"),(0,n.kt)("li",{parentName:"ul"},"'-' Open source version may be limited"),(0,n.kt)("li",{parentName:"ul"},"'-' Somewhat complicated deployment model")),(0,n.kt)("h3",{id:"option-3-aws-appconfig"},"Option #3: ",(0,n.kt)("a",{parentName:"h3",href:"https://docs.aws.amazon.com/appconfig/latest/userguide/what-is-appconfig.html"},"AWS AppConfig")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"'+' Not a lot of additional setup, App Eng already used to getting other configuration information from AWS"),(0,n.kt)("li",{parentName:"ul"},"'+' Very little Platform setup, AppEng already has limited access to AWS console"),(0,n.kt)("li",{parentName:"ul"},"'+' No separate approval, meets MilMove security requirements"),(0,n.kt)("li",{parentName:"ul"},"'-' Unknown cost"),(0,n.kt)("li",{parentName:"ul"},"'-' Very low level")),(0,n.kt)("h3",{id:"option-4-roll-our-own"},"Option #4: Roll our own"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"'+' Provides all flexibility we want"),(0,n.kt)("li",{parentName:"ul"},"'+' Easy to deploy (probably?) and meets MilMove security requirements"),(0,n.kt)("li",{parentName:"ul"},"'-' No easy way to migrate settings from one environment to another"),(0,n.kt)("li",{parentName:"ul"},"'-' We have to implement all the flexibility")),(0,n.kt)("h3",{id:"option-5-flipt"},"Option #5: ",(0,n.kt)("a",{parentName:"h3",href:"https://www.flipt.io"},"Flipt")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"'+' Provides flexibility to enable feature flags to groups of users in almost any configuration we could imagine"),(0,n.kt)("li",{parentName:"ul"},"'+' Open Source"),(0,n.kt)("li",{parentName:"ul"},"'+' Self hosted option is easy-ish to deploy, so meets MilMove security requirements"),(0,n.kt)("li",{parentName:"ul"},"'+' Gitops style, audited feature flag management"),(0,n.kt)("li",{parentName:"ul"},"'-' Additional service to deploy")))}h.isMDXComponent=!0}}]);