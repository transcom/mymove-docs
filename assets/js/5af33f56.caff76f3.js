"use strict";(self.webpackChunkmymove_docs=self.webpackChunkmymove_docs||[]).push([[5050],{47660:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var i=n(87462),a=(n(67294),n(3905));n(8209);const r={},o="Understanding MilMove Routing",l={unversionedId:"backend/guides/understanding-milmove-routing",id:"backend/guides/understanding-milmove-routing",title:"Understanding MilMove Routing",description:"This document is a brief summary on how routing on MilMove works.",source:"@site/docs/backend/guides/understanding-milmove-routing.md",sourceDirName:"backend/guides",slug:"/backend/guides/understanding-milmove-routing",permalink:"/mymove-docs/docs/backend/guides/understanding-milmove-routing",draft:!1,editUrl:"https://github.com/transcom/mymove-docs/edit/main/docs/backend/guides/understanding-milmove-routing.md",tags:[],version:"current",frontMatter:{},sidebar:"backendSidebar",previous:{title:"Golang Programming Guide",permalink:"/mymove-docs/docs/backend/guides/golang-guide"},next:{title:"AppContext: how and when to use it",permalink:"/mymove-docs/docs/backend/guides/use-stateless-services-with-app-context"}},d={},s=[{value:"Routing",id:"routing",level:2},{value:"Code Snippet Analysis",id:"code-snippet-analysis",level:2},{value:"Subrouting",id:"subrouting",level:3},{value:"Middleware",id:"middleware",level:3},{value:"Index Handler",id:"index-handler",level:3},{value:"Resources",id:"resources",level:2}],u={toc:s},h="wrapper";function p(e){let{components:t,...n}=e;return(0,a.kt)(h,(0,i.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"understanding-milmove-routing"},"Understanding MilMove Routing"),(0,a.kt)("p",null,"This document is a brief summary on how routing on MilMove works."),(0,a.kt)("h2",{id:"routing"},"Routing"),(0,a.kt)("p",null,"Routing is a mechanism where HTTP requests are routed to the code that handles them. It is how we determine what should happen when a user visits a certain URL.\nFor MilMove, the routing is initialized in ",(0,a.kt)("inlineCode",{parentName:"p"},"serve.go"),", which calls ",(0,a.kt)("inlineCode",{parentName:"p"},"InitRouting")," inside of ",(0,a.kt)("inlineCode",{parentName:"p"},"routing_init.go"),". This initializes the routing that will be used by the MilMove application. This sets up routing for all 3 sites, the MilMove application, office, and admin. Additionally, the routing for Prime API and Support API are is set up as well. Perhaps this not ideal, but this is how it works as of the writing of this document (December 2022).\nMilMove is using ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gorilla/mux"},"Gorilla Mux")," for routing."),(0,a.kt)("h2",{id:"code-snippet-analysis"},"Code Snippet Analysis"),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"This document won't analyze all the code related to how server side routing works, but select ones that are considered notable and for which there is extensive knowlege.")),(0,a.kt)("h3",{id:"subrouting"},"Subrouting"),(0,a.kt)("p",null,"Gorilla Mux allows easy configuration of matching routes.\nHere we are are matching by a path prefix. This means that any requests that are prefixed with ",(0,a.kt)("inlineCode",{parentName:"p"},"/static"),", will use the set middleware and handlers."),(0,a.kt)("p",null,"Here's the code with some comments to further explain."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'// Create a sub router for anything prefixed with "/static"\nstaticMux := site.PathPrefix("/static/").Subrouter()\n\n// Use the following middleware\nstaticMux.Use(middleware.ValidMethodsStatic(appCtx.Logger()))\nstaticMux.Use(middleware.RequestLogger(appCtx.Logger()))\n\n// Check if telemetryConfig is enabled before using the otel middleware\nif telemetryConfig.Enabled {\n    staticMux.Use(otelmux.Middleware("static"))\n}\n\n// All static GET and HEAD requests will use this handler.\nstaticMux.PathPrefix("/").Handler(clientHandler).Methods("GET", "HEAD")\n')),(0,a.kt)("h3",{id:"middleware"},"Middleware"),(0,a.kt)("p",null,"See ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/gorilla/mux#middleware"},"Gorilla Mux Middleware")," for details on middleware in general and how it works."),(0,a.kt)("p",null,"Occasionally in ",(0,a.kt)("inlineCode",{parentName:"p"},"routing_init.go")," you will see code that looks like the following."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},"staticMux.Use(middleware.ValidMethodsStatic(appCtx.Logger()))\n")),(0,a.kt)("p",null,"This is telling the static router to ",(0,a.kt)("em",{parentName:"p"},"use")," the ",(0,a.kt)("inlineCode",{parentName:"p"},"ValidMethodsStatic")," middleware."),(0,a.kt)("p",null,"Inside of",(0,a.kt)("inlineCode",{parentName:"p"},"valid_methods_static.go"),", we'll see the following code."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'func ValidMethodsStatic(logger *zap.Logger) func(inner http.Handler) http.Handler {\n    logger.Debug("ValidMethodsStatic Middleware used")\n    return func(inner http.Handler) http.Handler {\n        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {\n            if r.Method != "GET" && r.Method != "HEAD" {\n                http.Error(w, http.StatusText(http.StatusMethodNotAllowed), http.StatusMethodNotAllowed)\n                return\n            }\n            inner.ServeHTTP(w, r)\n        })\n    }\n}\n')),(0,a.kt)("p",null,"All middleware follows the format of returning a function which takes in an ",(0,a.kt)("inlineCode",{parentName:"p"},"http.Handler")," and returns an ",(0,a.kt)("inlineCode",{parentName:"p"},"http.Handler"),".\nInside this closure, one can do whatever one desires to do using the ",(0,a.kt)("inlineCode",{parentName:"p"},"http.ResponseWriter")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"http.Request"),".\nIn this case for ",(0,a.kt)("inlineCode",{parentName:"p"},"ValidMethodsStatic"),", the function checks if the request is either a ",(0,a.kt)("inlineCode",{parentName:"p"},"GET")," or a ",(0,a.kt)("inlineCode",{parentName:"p"},"HEAD")," request, and returns an error if the request is neither. Afterwards, it calls the next handler."),(0,a.kt)("h3",{id:"index-handler"},"Index Handler"),(0,a.kt)("p",null,"This index handler is used to handle all path prefixes that start with ",(0,a.kt)("inlineCode",{parentName:"p"},"/"),". In the following code snippet, the root would be the base URL. So for a request to ",(0,a.kt)("inlineCode",{parentName:"p"},"https://my.stg.move.mil/"),", the root would be ",(0,a.kt)("inlineCode",{parentName:"p"},"https://my.stg.move.mil")," and the Path Prefix would be ",(0,a.kt)("inlineCode",{parentName:"p"},"/"),". As a result, the request would be handled by the index handler."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'root.PathPrefix("/").Handler(indexHandler(routingConfig, appCtx.Logger())).Methods("GET", "HEAD")\n')),(0,a.kt)("p",null,"This is the corresponding ",(0,a.kt)("inlineCode",{parentName:"p"},"indexHandler")," function, with comments to explain."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-golang"},'// indexHandler returns a handler that will serve the resulting content\nfunc indexHandler(routingConfig *Config, globalLogger *zap.Logger) http.HandlerFunc {\n\n    // Get the path to the index file using the build root directory and the name index.html\n    indexPath := path.Join(routingConfig.BuildRoot, "index.html")\n\n    // Open the index.html file.\n    reader, err := routingConfig.FileSystem.Open(filepath.Clean(indexPath))\n\n    // If we can\'t open it, then log that client_build should be run\n    if err != nil {\n        globalLogger.Fatal("could not read index.html template: run make client_build", zap.Error(err))\n    }\n\n    // Get the status of the index.html file\n    stat, err := routingConfig.FileSystem.Stat(indexPath)\n\n    // We can\'t get the status, log error.\n    if err != nil {\n        globalLogger.Fatal("could not stat index.html template", zap.Error(err))\n    }\n\n    return func(w http.ResponseWriter, r *http.Request) {\n        // Serve the index.html file\n        http.ServeContent(w, r, "index.html", stat.ModTime(), reader)\n    }\n}\n')),(0,a.kt)("h2",{id:"resources"},"Resources"),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/gorilla/mux"},"Gorilla Mux")))}p.isMDXComponent=!0}}]);