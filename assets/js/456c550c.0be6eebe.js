"use strict";(self.webpackChunkmymove_docs=self.webpackChunkmymove_docs||[]).push([[537],{57386:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>r,toc:()=>m});var i=t(87462),a=(t(67294),t(3905));t(8209);const o={sidebar_position:8},s="React forms using Formik",r={unversionedId:"frontend/guides/react-forms-using-formik",id:"frontend/guides/react-forms-using-formik",title:"React forms using Formik",description:"See also: Create a Form Using Formik",source:"@site/docs/frontend/guides/react-forms-using-formik.md",sourceDirName:"frontend/guides",slug:"/frontend/guides/react-forms-using-formik",permalink:"/mymove-docs/docs/frontend/guides/react-forms-using-formik",draft:!1,editUrl:"https://github.com/transcom/mymove-docs/edit/main/docs/frontend/guides/react-forms-using-formik.md",tags:[],version:"current",sidebarPosition:8,frontMatter:{sidebar_position:8},sidebar:"frontendSidebar",previous:{title:"Icons",permalink:"/mymove-docs/docs/frontend/guides/icons"},next:{title:"Using Modals",permalink:"/mymove-docs/docs/frontend/guides/using-modals"}},l={},m=[{value:"Event Handling",id:"event-handling",level:2},{value:"Validation",id:"validation",level:2},{value:"Submission",id:"submission",level:2},{value:"Testing",id:"testing",level:2},{value:"Simulating events",id:"simulating-events",level:3},{value:"Mocking functions",id:"mocking-functions",level:3},{value:"Async concerns",id:"async-concerns",level:3},{value:"Accessibility",id:"accessibility",level:2}],u={toc:m},c="wrapper";function d(e){let{components:n,...t}=e;return(0,a.kt)(c,(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"react-forms-using-formik"},"React forms using Formik"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"See also:")," ",(0,a.kt)("a",{parentName:"p",href:"/mymove-docs/docs/frontend/guides/create-a-form-using-formik"},"Create a Form Using Formik")),(0,a.kt)("p",null,"On the frontend MyMove is migrating from creating forms using the ",(0,a.kt)("a",{parentName:"p",href:"https://redux-form.com/"},"redux-form")," library in favor of ",(0,a.kt)("a",{parentName:"p",href:"https://formik.org/"},"Formik"),". One major reason for the change is the desire to remove storing frequent state changes in the global redux store, when most form components can manage this locally. Using this pattern will ideally lead to more performant and self contained code."),(0,a.kt)("p",null,"As we migrate and introduce new forms using Formik, this can be a place to collect best practices that we learn along the way."),(0,a.kt)("h2",{id:"event-handling"},"Event Handling"),(0,a.kt)("p",null,"Formik has supplied built in event handlers that it favors over creating individual ones for each input. Of course you are still free to create custom listeners and will need to for things such as click events. Built-in listeners include ",(0,a.kt)("inlineCode",{parentName:"p"},"handleChange"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"handleBlur"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"handleReset")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"handleSubmit"),"."),(0,a.kt)("p",null,"Formik then uses the ",(0,a.kt)("inlineCode",{parentName:"p"},"name")," attribute to distinguish which input triggered the event.  All of your fields require defaults specified in the ",(0,a.kt)("inlineCode",{parentName:"p"},"initialValues")," object.  After update and during submission the current values are provided in the ",(0,a.kt)("inlineCode",{parentName:"p"},"values")," object."),(0,a.kt)("h2",{id:"validation"},"Validation"),(0,a.kt)("p",null,"TBD"),(0,a.kt)("h2",{id:"submission"},"Submission"),(0,a.kt)("p",null,"Your submit action gets defined in the ",(0,a.kt)("inlineCode",{parentName:"p"},"onSubmit")," property when instantiating Formik.  This is the function that gets called when ",(0,a.kt)("inlineCode",{parentName:"p"},"handleSubmit")," is invoked either automatically from an event listener or by manually calling ",(0,a.kt)("inlineCode",{parentName:"p"},"submitForm"),".  Validation will need to succeed for submission to continue otherwise errors will be set and submission aborts."),(0,a.kt)("p",null,"Assuming no validation errors your submit function will be called with the values from the form and other helper actions (",(0,a.kt)("a",{parentName:"p",href:"https://formik.org/docs/api/withFormik#the-formikbag"},"FormikBag"),").  It's important to note this submit function can be either synchronous or async.  If it is declared synchronously, then you must call ",(0,a.kt)("inlineCode",{parentName:"p"},"setSubmitting(false)")," when all work has finished.  "),(0,a.kt)("h2",{id:"testing"},"Testing"),(0,a.kt)("p",null,"Our testing setup currently includes using Jest and Enzyme when testing components.  There may be some non-intuitive gotchas to test that your Formik fields and handlers work correctly."),(0,a.kt)("h3",{id:"simulating-events"},"Simulating events"),(0,a.kt)("p",null,"To test our component we often want to mimic the user's interactions such as typing, clicking, and submitting a form.  Here is an example of testing that a validation error is displayed for our form that has an email input with a handleChange listener setup."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"//FormComponent.test.jsx\n\nit('displays error message on invalid email input', () => {\n    // mount the component we're testing, shallow rendering is not possible\n    const wrapper = mount(<FormComponent />)\n\n    // any actions causing state changes should be contained in act blocks or you may see errors\n    act(() => {\n        // Formik will not automatically provide the name identifier for your form element it\n        // must be part of the event payload.\n        wrapper\n            .find('input[name=\"email\"]')\n            .simulate('change', { target: { name: \"email\", value:\"@@example.com\" } })\n    })\n\n    // assert that the error message is displayed after an invalid email value is entered\n    expect(wrapper.find('#emailErrorMessage').text()).toBe(\"invalid character '@' in email format\")\n})\n")),(0,a.kt)("h3",{id:"mocking-functions"},"Mocking functions"),(0,a.kt)("p",null,"It's likely you'll be passing function props to your component for custom listeners for click and submit events.  In our test we'll want to ",(0,a.kt)("a",{parentName:"p",href:"https://jestjs.io/docs/en/mock-functions.html"},"mock these values with Jest"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"//FormComponent.test.jsx\n\nit('calls the onSubmit function prop when save is clicked', () => {\n    // replace our real implementation with a mock one, this could also have an implementation or return a promise\n    const onSubmit = jest.fn();\n    // assuming our function is passed as a prop to the component\n    const wrapper = mount(<FormComponent onSubmit={onSubmit}/>)\n\n    // any actions causing state changes should be contained in act blocks or you may see errors\n    act(() => {\n        // our save button has a click handler set to handleSubmit\n        // another option would be to simulate the submit event on the form element itself\n        wrapper\n            .find('button[name=\"save\"]')\n            .simulate('click', { target: { name: \"save\" } })\n    })\n\n    // assert that our function was called at least once\n    expect(onSubmit).toHaveBeenCalled()\n})\n")),(0,a.kt)("h3",{id:"async-concerns"},"Async concerns"),(0,a.kt)("p",null,"You may run into difficulty because of the async nature of the event callbacks and making sure your tests don't run assertions before these updates have concluded."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"\n// create a test case that can use async/await \nit('calls the onSubmit function prop when save is clicked', async () => {\n\n})\n")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"\n// wait for simulated events and state changes to finish prior to assertions\nawait act(async () => {\n    form.simulate('submit')\n})\n")),(0,a.kt)("p",null,"Finally if the state has changed of your component, calling Enzyme's ",(0,a.kt)("a",{parentName:"p",href:"https://enzymejs.github.io/enzyme/docs/api/ReactWrapper/update.html"},"update function")," to sync can help if your assertions are failing."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"const wrapper = mount(<FormComponent />)\n\n// wait for simulated events and state changes to finish prior to assertions\nawait act(async () => {\n    form.simulate('submit')\n})\n// state has changed so resync our component (not rerender)\nwrapper.update()\n\n// now do your assertion\n")),(0,a.kt)("h2",{id:"accessibility"},"Accessibility"),(0,a.kt)("p",null,"TBD"))}d.isMDXComponent=!0}}]);