"use strict";(self.webpackChunkmymove_docs=self.webpackChunkmymove_docs||[]).push([[8839],{15147:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var i=a(87462),n=(a(67294),a(3905));a(8209);const o={title:"0053 Use React Query for Office App API interactions"},r="Use React Query for Office App API interactions",s={unversionedId:"adrs/use-react-query-office-app",id:"adrs/use-react-query-office-app",title:"0053 Use React Query for Office App API interactions",description:"We are currently making heavy use of Redux in both the Office app & customer-facing app to manage API data in the browser. While there are other valid reasons to continue using Redux, it does put a lot of overhead on our code to handle fetching data, providing the correct data to the correct UI components, and deciding when to invalidate or re-fetch data that has become stale. This article (Why I Quit Redux) explains pretty well why this is less than ideal, and also proposes using a library called React Query as an alternative.",source:"@site/docs/adrs/0053-use-react-query-office-app.md",sourceDirName:"adrs",slug:"/adrs/use-react-query-office-app",permalink:"/mymove-docs/docs/adrs/use-react-query-office-app",draft:!1,editUrl:"https://github.com/transcom/mymove-docs/edit/main/docs/adrs/0053-use-react-query-office-app.md",tags:[],version:"current",sidebarPosition:53,frontMatter:{title:"0053 Use React Query for Office App API interactions"},sidebar:"adrsSidebar",previous:{title:"0052 Use data-testid as an attribute for finding components in tests",permalink:"/mymove-docs/docs/adrs/use-data-testid"},next:{title:"0054 Use CSS to highlight unfinished features",permalink:"/mymove-docs/docs/adrs/use-CSS-to-highlight-unfinished-features"}},l={},d=[{value:"Considered Alternatives",id:"considered-alternatives",level:2},{value:"Decision Outcome",id:"decision-outcome",level:2},{value:"Pros and Cons of the Alternatives",id:"pros-and-cons-of-the-alternatives",level:2},{value:"SwaggerRequest as-is",id:"swaggerrequest-as-is",level:3},{value:"Redux-Saga",id:"redux-saga",level:3},{value:"React-Query",id:"react-query",level:3}],c={toc:d},u="wrapper";function h(e){let{components:t,...a}=e;return(0,n.kt)(u,(0,i.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"use-react-query-for-office-app-api-interactions"},"Use React Query for Office App API interactions"),(0,n.kt)("p",null,"We are currently making heavy use of ",(0,n.kt)("a",{parentName:"p",href:"https://redux.js.org/"},"Redux")," in both the Office app & customer-facing app to manage API data in the browser. While there are other valid reasons to continue using Redux, it does put a lot of overhead on our code to handle fetching data, providing the correct data to the correct UI components, and deciding when to invalidate or re-fetch data that has become stale. ",(0,n.kt)("a",{parentName:"p",href:"https://dev.to/g_abud/why-i-quit-redux-1knl"},"This article (",(0,n.kt)("em",{parentName:"a"},"Why I Quit Redux"),")")," explains pretty well why this is less than ideal, and also proposes using a library called ",(0,n.kt)("a",{parentName:"p",href:"https://react-query.tanstack.com/"},"React Query")," as an alternative."),(0,n.kt)("p",null,"After seeing that React Query follows many of the same conventions as ApolloClient (a client data-layer tool used with GraphQL), I decided to investigate further, since using ApolloClient on previous projects significantly reduced the amount of overhead work when hooking up the API to the frontend. After testing this out with a basic existing query, I believe if we take advantage of this tool, it will both reduce complexity of our frontend codebase and speed up our progress. Please see the ",(0,n.kt)("a",{parentName:"p",href:"#pros-and-cons-of-the-alternatives"},"Pros and Cons")," section for more technical details and comparison points."),(0,n.kt)("h2",{id:"considered-alternatives"},"Considered Alternatives"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Continue using SwaggerRequest thunk as-is (do nothing)"),(0,n.kt)("li",{parentName:"ul"},"Use ",(0,n.kt)("a",{parentName:"li",href:"https://redux-saga.js.org/"},"Redux-Saga")," for managing API interactions"),(0,n.kt)("li",{parentName:"ul"},"Use React-Query")),(0,n.kt)("h2",{id:"decision-outcome"},"Decision Outcome"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Chosen Alternative: React-Query for Office app (starting with TXO)"),(0,n.kt)("li",{parentName:"ul"},"It's important to note that none of these options are incompatible with each other, meaning this is not an all-or-nothing decision. ",(0,n.kt)("em",{parentName:"li"},"However")," we want to avoid using too many patterns simultaneously, so I recommend scoping this change to an explicitly defined area of the codebase (in this case, the TXO pages)."),(0,n.kt)("li",{parentName:"ul"},"Additionally, there is some risk in React Query co-existing with Redux entities in that it means API data is cached in two locations and could fall out of sync. My recommendation is that we start by using React Query for ",(0,n.kt)("em",{parentName:"li"},"all")," TXO pages, and plan to migrate PPM Office pages when they undergo redesigns. Since the customer-facing app has a significantly different use-case and does not involve fetching data simultaneously with the Office pages, migrating that app is less of an immediate concern."),(0,n.kt)("li",{parentName:"ul"},"Assuming this decision is well-communicated and learning resources are provided to the team members responsible for implementation, I believe this will have a significant impact on how quickly we are able to build robust UI for the Office users and meet our deadlines."),(0,n.kt)("li",{parentName:"ul"},"If we begin to use React Query and run into issues or decide that it is not the right choice, this decision can be reversed by changing the code we've written to use one of the alternatives.")),(0,n.kt)("h2",{id:"pros-and-cons-of-the-alternatives"},"Pros and Cons of the Alternatives"),(0,n.kt)("h3",{id:"swaggerrequest-as-is"},"SwaggerRequest as-is"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"+")," no changes needed to what we're already doing (and it's working for us, for now)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-")," in most places is fetching data on ",(0,n.kt)("inlineCode",{parentName:"li"},"componentDidMount"),", and needs explicit handling to trigger re-fetches if data is changed (such as after submitting a form or ",(0,n.kt)("inlineCode",{parentName:"li"},"PUT")," request), or to re-fetch if props that API calls rely on change (such as the ID of a resource being viewed)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-")," uses the heavily abstracted SwaggerRequest function, which is currently responsible for all of:",(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},"dispatching actions to log the request start and success or error"),(0,n.kt)("li",{parentName:"ul"},"making the request itself using SwaggerClient fetch"),(0,n.kt)("li",{parentName:"ul"},"normalizing the data that comes back in the response"),(0,n.kt)("li",{parentName:"ul"},"updating the response data in Redux"),(0,n.kt)("li",{parentName:"ul"},"Because all of this is handled by a single function, it can be difficult to debug, and high-risk to change if, for example, edge-cases need to be handled."))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-")," Requires a significant amount of boilerplate code in order to select data from Redux and handle entity actions & reducer")),(0,n.kt)("h3",{id:"redux-saga"},"Redux-Saga"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"+")," gives us the tools to start splitting up the things happening in SwaggerRequest (logging, fetching, normalizing, updating data) iteratively and safely"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"+")," makes it easier to chain together fetch flows (load resource A -> load resource B -> etc.)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"+")," makes it easier to test data flows"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-")," continues to rely on Redux for managing API data"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-")," would mean adding even more boilerplate code (for example, to start saga watchers and dispatch actions that trigger sagas)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-")," has a significant learning curve, for both ES6 generators and the saga effects API"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-")," doesn\u2019t solve the problem of having to explicitly re-fetch or invalidate cached data (but does make it more visible and easier to control)")),(0,n.kt)("h3",{id:"react-query"},"React-Query"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"+")," removes the need to use Redux for any API data caching, meaning a whole lot of code ",(0,n.kt)("em",{parentName:"li"},"could")," be removed"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"+"),' handles caching and API optimization "for free" (i.e., when you call ',(0,n.kt)("inlineCode",{parentName:"li"},"useQuery")," it will decide whether to re-fetch data or to use cached data) and provides configuration options to fine-tune this"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"+")," provides patterns for invalidating cached data, updating data on mutation responses (such as after submitting a form), and chaining API calls. These are all things we do often, and can be difficult to get right when done manually."),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"+")," has a few bells and whistles around data-layer management (i.e.: refresh queries on window focus, query retries, pagination/infinite scroll)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"+")," ",(0,n.kt)("inlineCode",{parentName:"li"},"useQuery")," and ",(0,n.kt)("inlineCode",{parentName:"li"},"useMutation")," patterns lend themselves to easily mocking responses from API endpoints that don't exist yet or aren't fully implemented"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"+")," not reliant on ES6 generators which need an extra runtime polyfill for some browsers"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-")," would require writing (a) function(s) to use instead of ",(0,n.kt)("inlineCode",{parentName:"li"},"SwaggerRequest")," that have to handle making the API calls and returning normalized data (without Redux)"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-")," dependent on using ",(0,n.kt)("a",{parentName:"li",href:"https://reactjs.org/docs/hooks-intro.html"},"hooks")," for making API interactions, which can only be used in functional components"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"-")," React-Query is a relatively new library (as of Fall 2019) and is also new to us, so there could always be surprises or unknown issues"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"=")," documentation is robust and there is a devtools extension for debugging"),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("inlineCode",{parentName:"li"},"=")," API includes ",(0,n.kt)("a",{parentName:"li",href:"https://react-query.tanstack.com/docs/api#reactquerycacheprovider"},(0,n.kt)("inlineCode",{parentName:"a"},"ReactQueryCacheProvider"))," which can be used to provide data for unit tests (similar to Redux's Provider)")))}h.isMDXComponent=!0}}]);