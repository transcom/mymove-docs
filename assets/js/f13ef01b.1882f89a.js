"use strict";(self.webpackChunkmymove_docs=self.webpackChunkmymove_docs||[]).push([[1957],{65087:(e,t,o)=>{o.r(t),o.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>r,toc:()=>d});var a=o(87462),n=(o(67294),o(3905));o(8209);const i={sidebar_position:18},s="Loop Iteration in Golang",r={unversionedId:"backend/guides/golang-loops",id:"backend/guides/golang-loops",title:"Loop Iteration in Golang",description:"Introduction",source:"@site/docs/backend/guides/golang-loops.md",sourceDirName:"backend/guides",slug:"/backend/guides/golang-loops",permalink:"/mymove-docs/docs/backend/guides/golang-loops",draft:!1,editUrl:"https://github.com/transcom/mymove-docs/edit/main/docs/backend/guides/golang-loops.md",tags:[],version:"current",sidebarPosition:18,frontMatter:{sidebar_position:18},sidebar:"backendSidebar",previous:{title:"Time in Golang",permalink:"/mymove-docs/docs/backend/guides/golang-time"},next:{title:"Turning TDL scores and TSP discounts into transportation service provider performances",permalink:"/mymove-docs/docs/backend/guides/tspp-data-creation"}},l={},d=[{value:"Introduction",id:"introduction",level:2},{value:"Problem Manifestation",id:"problem-manifestation",level:2},{value:"Discovery",id:"discovery",level:2},{value:"How to Fix",id:"how-to-fix",level:2},{value:"References",id:"references",level:2}],p={toc:d},c="wrapper";function m(e){let{components:t,...o}=e;return(0,n.kt)(c,(0,a.Z)({},p,o,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"loop-iteration-in-golang"},"Loop Iteration in Golang"),(0,n.kt)("h2",{id:"introduction"},"Introduction"),(0,n.kt)("p",null,"When writing loops in Go, you should be aware of how Go instantiates and uses loop variables. Consider this example\n",(0,n.kt)("a",{parentName:"p",href:"https://github.com/transcom/mymove/blob/b173c32688c6f1e4fedc58aaf46fd88e4afb04af/pkg/handlers/primeapi/payloads/model_to_payload.go#L55-L58"},"from our code history"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"for i, m := range *moveTaskOrders {\n    payload[i] = MoveTaskOrder(&m)\n}\n")),(0,n.kt)("p",null,"Go will create a single variable ",(0,n.kt)("inlineCode",{parentName:"p"},"m")," that receives a copy of each item in the ",(0,n.kt)("inlineCode",{parentName:"p"},"moveTaskOrders")," slice. Because ",(0,n.kt)("inlineCode",{parentName:"p"},"m")," is\nnot reallocated with each loop iteration, taking the address of m (",(0,n.kt)("inlineCode",{parentName:"p"},"&m"),") like done above will result in an identical\npointer value every time through the loop. That can have subtle consequences that you need to keep in mind."),(0,n.kt)("h2",{id:"problem-manifestation"},"Problem Manifestation"),(0,n.kt)("p",null,"The purpose of the code above is to translate a tree of model structs to a swagger-generated payload struct to be\nreturned by an endpoint. However, in some cases during this translation, we take the addresses of items and\n",(0,n.kt)("a",{parentName:"p",href:"https://github.com/transcom/mymove/blob/b173c32688c6f1e4fedc58aaf46fd88e4afb04af/pkg/handlers/primeapi/payloads/model_to_payload.go#L181-L183"},"copy them to their corresponding fields"),"\nin the payload structure:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"return &primemessages.Address{\n    // ...\n    City:       &address.City,\n    State:      &address.State,\n    PostalCode: &address.PostalCode,\n    // ...\n}\n")),(0,n.kt)("p",null,"The behavior we were seeing in the case above was that some fields like those above in the payload's ",(0,n.kt)("inlineCode",{parentName:"p"},"Address")," structure\nappeared to be the same regardless of what was in the database or the ",(0,n.kt)("inlineCode",{parentName:"p"},"Address")," model (both of which were correct).\nIn fact, those fields would always be set to the values in the ",(0,n.kt)("em",{parentName:"p"},"last")," ",(0,n.kt)("inlineCode",{parentName:"p"},"Address")," that was processed in the loop. This is\nconsistent with the Go loop behavior mentioned above since the payload fields point to the correct\nvalues in each iteration, but the subsequent iterations will overwrite the data pointed to and therefore make\nthem all appear to be the same after each loop iteration."),(0,n.kt)("p",null,"Note that this does not happen to every field in the payload because we are often not doing a direct pointer copy.\nIf we're just copying a value type to another value type, a copy of the value is being made so it's disassociated\nfrom the source. If we're copying a pointer to data that is not being replaced -- for instance, if the model was\nalready storing a ",(0,n.kt)("inlineCode",{parentName:"p"},"*string")," for instance, then we seem to be OK too since that pointer is to a different piece of memory, not\nthe loop iterator variable. It's only a problem when we're copying the address of some item in the loop\niterator variable (at least in this particular case) since that memory location will not change across iterations.\nAs you can see, there are some subtleties involved."),(0,n.kt)("h2",{id:"discovery"},"Discovery"),(0,n.kt)("p",null,"We recently upgraded to a newer version of ",(0,n.kt)("inlineCode",{parentName:"p"},"golangci-lint")," which includes a newer ",(0,n.kt)("inlineCode",{parentName:"p"},"gosec")," that will flag cases where\nit thinks this situation occurs. The specific linter warning returned is ",(0,n.kt)("inlineCode",{parentName:"p"},"G601: Implicit memory aliasing of items\nfrom a range statement"),"."),(0,n.kt)("h2",{id:"how-to-fix"},"How to Fix"),(0,n.kt)("p",null,"The most straightforward fix is to make a local copy of the loop iterator variable within the loop itself, then\ntake the address of it. Since that local variable is scoped to the loop, it should be a different memory address\nwith each iteration. So, given our initial example above, we could change it to the following to prevent the\noverwriting scenario described above:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"for i, m := range *moveTaskOrders {\n    copyOfM := m // Make copy to avoid implicit memory aliasing of items from a range statement.\n    payload[i] = MoveTaskOrder(&copyOfM)\n}\n")),(0,n.kt)("p",null,"Another alternative is to take the address of the slice elements instead:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"for i := range *moveTaskOrders {\n    // Take the address of the slice element to avoid implicit memory aliasing of items from a range statement.\n    payload[i] = MoveTaskOrder(&moveTaskOrders[i])\n}\n")),(0,n.kt)("p",null,"If using that strategy, keep in mind that you may be storing pointers to\nexisting slice elements, so there are some garbage collection and concurrency\nconcerns to consider (as noted in this ",(0,n.kt)("a",{parentName:"p",href:"https://stackoverflow.com/a/48826629"},"Stack Overflow\nanswer"),")."),(0,n.kt)("p",null,"A casual observer who hasn't been exposed to this loop behavior may see the fixes above as unnecessary, so regardless\nof which fix you apply, be sure to add a comment to let them know that the fix was done on purpose and should not\nbe accidentally undone."),(0,n.kt)("p",null,"Another option that achieves a similar goal would be to change the called function/method's signature to accept a ",(0,n.kt)("a",{parentName:"p",href:"https://goinbigdata.com/golang-pass-by-pointer-vs-pass-by-value/"},"value type rather\nthan a reference"),":"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-go"},"for i, m := range *moveTaskOrders {\n    payload[i] = MoveTaskOrder(m)\n}\n")),(0,n.kt)("p",null,"You would no longer need the local copy in that case as calling the method would automatically make a copy, but\nyou would have to refactor all calls to that function/method since you would be changing its signature."),(0,n.kt)("h2",{id:"references"},"References"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Golang Wiki: ",(0,n.kt)("a",{parentName:"li",href:"https://github.com/golang/go/wiki/CommonMistakes#using-reference-to-loop-iterator-variable"},"Using reference to loop iterator variable")),(0,n.kt)("li",{parentName:"ul"},"Stack Overflow: ",(0,n.kt)("a",{parentName:"li",href:"https://stackoverflow.com/questions/48826460/using-pointers-in-a-for-loop"},"Using Pointers in a for loop")),(0,n.kt)("li",{parentName:"ul"},"Stack Overflow: ",(0,n.kt)("a",{parentName:"li",href:"https://stackoverflow.com/questions/62446118/implicit-memory-aliasing-in-for-loop"},"Implicit memory aliasing in for loop")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.evanjones.ca/go-gotcha-loop-variables.html"},"Go Gotcha: Don't take the address of loop variables"))))}m.isMDXComponent=!0}}]);